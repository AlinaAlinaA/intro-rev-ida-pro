# Часть 58

 Хорошо. Нам осталось добавить сам шеллкод. Это типичный шеллкод, который крадет токен процесса **SYSTEM** и копирует его в наш процесс. Он очень короткий. Но стоит его хорошо проанализировать.  
  
shellcode=**"\x53\x56\x57\x60\x33\xC0\x64\x8B\x80\x24\x01\x00\x00\x8B\x40\x50\x8B\xC8\xBA\x04\x00\x00\x00\x8B\x80\xB8\x00\x00\x00\x2D\xB8\x00\x00\x00\x39\x90\xB4\x00\x00\x00\x75\xED\x8B\x90\xF8\x00\x00\x00\x89\x91\xF8\x00\x00\x00\x61\x33\xC0\x83\xC4\x0C\x5D\xC2\x08\x00"**  
  
Шеллкод - довольно общий. То, что нужно знать про шеллкод, состоит в том, что когда он завершается, он возвращается к процедуре откуда он был вызван. Для этого нужно внимательно посмотреть. Последняя инструкция **RETN** должна быть **RETN** **4** или больше, чтобы вернуться туда куда нужно. Если бы мы не перезаписали **RET** случилось бы переполнение и программа продолжила работу. Иначе будет **BSOD** и чао-какао.  
  
![1.png](https://wasm.in/attachments/1-png.4071/)   
  
Здесь мы видим, как я разместил шеллкод. В начале данных, которые я пересылаю, я размещаю шеллкод и затем вычитаю **820** байт из длины этого же самого шеллкода для того, чтобы он не изменил положение значения, которым я перезаписываю адрес возврата в дальнейшем и сохраняю его правильным.  
  
Если бы я запустил скрипт, прежде чем объяснять вам всё это, мы бы увидим, что я поместил вызов **RAW\_INPUT** в конец скрипта, чтобы остановить его до того, как он закроется, и посмотрим, смогу ли я повысить системные привилегии. Вы также можете запустить другой процесс и увидеть, есть ли у этого процесса системные привилегии, что может произойти только в том случае, если один системный процесс запускается другим.  
  
![2.png](https://wasm.in/attachments/2-png.4072/)   
  
Здесь я запустил скрипт. Я вижу, что скрипт остановился на вызове **RAW**\_**INPUT.** Давайте посмотрим в **PROCESS** **EXPLORER.** Добавим столбец, который показывает текущего пользователя, который говорит нам следующее  
  
![3.png](https://wasm.in/attachments/3-png.4073/)   
  
Мы работали над преобразованием процесса с привилегиями обычного пользователя в **SYSTEM.** Давайте посмотрим, как мы это сделали. Присоединим **IDA** и остановимся на инструкции **RET** перед выполнением шеллкода.  
  
![4.png](https://wasm.in/attachments/4-png.4074/)   
  
Здесь код остановился у инструкции **RET.** Мы трассируем один раз с помощью **F7**.  
  
![5.png](https://wasm.in/attachments/5-png.4075/)   
  
Здесь находится шеллкод. Он очень маленький и мы видим, что он заканчивается на инструкции **RETN** **8.** Это значение должно быть хорошо отрегулировано, потому что под адресом возврата, который мы перезаписываем в стеке, чтобы выполнять наш шеллкод, находится адрес возврата в родительскую функцию, и это то, что мы действительно должны достичь с помощью этого **RET**, чтобы вернуться в программу так как родительская функция сделала бы это.  
  
С помощью **P** мы можем создать функцию **CREATE** **FUNCTION** и преобразить её в графическую форму с помощью пробела.  
  
![6.png](https://wasm.in/attachments/6-png.4076/)   
  
После инструкции **PUSHA**, которая сохраняет регистры в стеке, мы видим, что, поскольку **EAX** равно **0** из-за инструкции **XOR и** программа заканчивает чтение значения регистра **FS**:\[**124**\]  
  
Хорошо. Каждый процесс имеет **TEB** или **TIB**.  
  
[https://es.wikipedia.org/wiki/Win32\_Thread\_Information\_Block](https://es.wikipedia.org/wiki/Win32_Thread_Information_Block)  
  
В вычислительной технике, **WIN32** **THREAD** **INFORMATION** **BLOCK** \(**TIB**\) эта структура данных в системах **WIN32**, особенно в архитектуре **X86**, которая хранит информацию о потоке, который выполняется. Также она известна как **THREAD** **ENVIRONMENT** **BLOCK** \(**TEB**\).  
  
Хорошо. Эта структура имеет поля, к которым обращается через регистр **FS**:\[**x**\]. Здесь в таблице мы видим, например, **FS**:\[**124**\]  
  
![7.png](https://wasm.in/attachments/7-png.4077/)   
  
Также, широко используется указатель на **PEB**, что расшифровывается как **PROCESS** **ENVIRONMENT** **BLOCK**, который находится в **FS**:\[**30**\]  
  
![8.png](https://wasm.in/attachments/8-png.4078/)   
  
В **WINDBG** вы можете увидеть эту структуру.  
  
![9.png](https://wasm.in/attachments/9-png.4079/)   
  
Хотя смещение **0x124** не показывается нам даже если мы придадим структуре большую глубину. Как мы видели, это структура **ETHREAD**.  
  
![10.png](https://wasm.in/attachments/10-png.4080/)   
  
Как и в позиции **0,** это структура **KTHREAD** или **KERNEL** **THREAD.** Это означает, что поле **50**, которое программа ищет дальше внутри структуры **ETHREAD**, будет находиться внутри **KTHREAD**, потому что последняя имеет размер **0x200**.  
  
![11.png](https://wasm.in/attachments/11-png.4081/)   
  
![12.png](https://wasm.in/attachments/12-png.4082/)   
  
Мы видим, что поле **0x50** не показывается нам. Оно находится внутри структуры \_**KAPC**\_**STATE** которая находится по смещению **0x40**.  
  
Посмотрим её. По смещению **0x10** это \_**KPROCESS**.  
  
![13.png](https://wasm.in/attachments/13-png.4083/)   
  
Если мы читаем это значение, и передаем его в регистр **EAX**, мы видим, что это знаменитый **EPROCESS** или **KPROCESS** - то же самое? Нет, но почти.  
  
![14.png](https://wasm.in/attachments/14-png.4084/)   
  
Мы видим, что **KPROCESS** находится в поле **0** **EPROCESS**, так что всё нормально, адрес совпадает. Если начиная с этого значения, сумма смещения меньше чем **0x98**, это будет **KPROCESS** и находится внутри этого. Если сумма больше **0x98**, это будет в оставшейся части структуры **EPROCESS**.  
  
![15.png](https://wasm.in/attachments/15-png.4085/)   
  
Мы видим, что программа читает поле **0xB8**, поэтому мы уже вышли из структуры **KPROCESS** и находимся внутри **EPROCESS**.  
  
![16.png](https://wasm.in/attachments/16-png.4086/)   
  
Программа читает знаменитую **ACTIVEPROCESSLINKS**.  
  
Как и в предыдущем упражнении, я собрал структуру **EPROCESS**, которая была неполной, но она работает.  
  
![17.png](https://wasm.in/attachments/17-png.4087/)   
  
Через меню **FILE→** **LOAD** **FILE→** **PARSE** **C** **HEADER** **FILE** я ищу структуру и добавляю её.  
  
![18.png](https://wasm.in/attachments/18-png.4088/)   
  
Я помечаю её через **LOCAL** **TYPES** и экспортирую её в файл **C** **HEADER**  
  
![19.png](https://wasm.in/attachments/19-png.4089/)   
  
Теперь происходит синхронизация.  
  
![20.png](https://wasm.in/attachments/20-png.4090/)   
  
![21.png](https://wasm.in/attachments/21-png.4091/)   
  
Я нажимаю **T** и ищу структуру. И это наш **FLINK.** Другими словами, он указывает на **ACTIVEPROCESSLINK** следующего процесса, так как он находится по смещению **0xB8.** Программа вычитает эту константу, чтобы найти **EPROCESS** следующего процесса.  
  
![22.png](https://wasm.in/attachments/22-png.4092/)   
  
В регистре **EAX** должен быть указатель на **EPROCESS** следующего процесса.  
  
![23.png](https://wasm.in/attachments/23-png.4093/)   
  
Поскольку больше ничего нет, я думаю, вы должны указать на начало таблицы, чтобы заново начать ходить по ней. Давайте посмотрим.  
  
Мы видим, что программа сравнивает значение поля **0xB4** этого **EPROCESS** со значением **4.** Давайте посмотрим, что это смещение **0xB4.** Поэтому мы добавляем его в нашу структуру.  
  
![24.png](https://wasm.in/attachments/24-png.4094/)   
  
![25.png](https://wasm.in/attachments/25-png.4095/)   
  
То есть, программа замечает, что если **PID** равен **4**, это соответствует процессу **SYSTEM**.  
  
Я добавлю поле в мою структуру. Программа не позволяет редактировать структуру, потому что я импортирую её, поэтому я добавил поле в .**H** файл, который я экспортировал.  
  
![26.png](https://wasm.in/attachments/26-png.4096/)   
  
Я повторно импортирую файл, не удаляя предыдущий, и добавляется недостающее поле.  
  
![27.png](https://wasm.in/attachments/27-png.4097/)   
  
Я нахожусь здесь.  
  
Мы видим, что значение не равно **4**, поэтому мы продолжаем трассировать. Конечно, всё начнется снова с первого процесса. Давайте посмотрим.  
  
![28.png](https://wasm.in/attachments/28-png.4098/)   
  
Здесь программа начинается с начала. В этом случае **PID** или **CID** равен **4** и соответствует процессу **SYSTEM**.  
  
![29.png](https://wasm.in/attachments/29-png.4099/)   
  
Теперь если программа найдет **EPROCESS** процесса **SYSTEM**, она выйдет из цикла.  
  
![30.png](https://wasm.in/attachments/30-png.4100/)   
  
Мы видим, что программа читает поле **0xF8** **EPROCESS** процесса **SYSTEM.** Давайте посмотрим, что там есть.  
  
![31.png](https://wasm.in/attachments/31-png.4101/)   
  
![32.png](https://wasm.in/attachments/32-png.4102/)   
  
Хорошо. Программа копирует токен системы в наш **EPROCESS**. Он будет иметь привилегии **SYSTEM**, и вот что программа там делает. Читает токен **SYSTEM**.  
  
![33.png](https://wasm.in/attachments/33-png.4103/)   
  
И поскольку регистр **ECX** имел наш **EPROCESS**, к нему добавляется значение **0xF8**, чтобы сохранить токен **SYSTEM** в нашем процессе.  
  
![34.png](https://wasm.in/attachments/34-png.4104/)   
  
Я могу добавить недостающее поле в .**H** файл и импортировать его снова. Нет необходимости удалять предыдущий.  
  
![35.png](https://wasm.in/attachments/35-png.4105/)   
  
Помните, что значения являются токенами разных процессов. Регистр **EAX** указывает на **EPROCESS** **SYSTEM,** а **ECX** на наш **EPROCESS** из **PYTHON**.**EXE**.  
  
С этим уже все работает как нужно. Давайте посмотрим, сможем ли мы с этим **RET** нормально вернутся обратно в программу и продолжить работу с драйвером.  
  
![36.png](https://wasm.in/attachments/36-png.4106/)   
  
Программа вернулась в ту же самую точку, куда она должна была вернуться, если бы вместо того, чтобы выполнить наш шеллкод, она возвратилась к уязвимой функции. Со стеком в той же самой позиции. Нужно убедиться в этом, иначе снова будет **BSOD**.  
  
![37.png](https://wasm.in/attachments/37-png.4107/)   
  
Я нажимаю **RUN** и остаюсь в ожидании функции **RAW**\_**INPUT**.  
  
У меня сейчас нет **PROCESS** **EXPLORER.** Я закрыл его, чтобы он обновился.  
  
![38.png](https://wasm.in/attachments/38-png.4108/)   
  
И у нас есть готовые права **SYSTEM**.  
  
Я могу запустить калькулятор с правами **SYSTEM.**  
  
![39.png](https://wasm.in/attachments/39-png.4109/)   
  
![40.png](https://wasm.in/attachments/40-png.4110/)   
  
Готово. Мы достигли цели.  
  
**=======================================================  
Автор текста: Рикардо Нарваха** - **Ricardo** **Narvaja** \(**@ricnar456**\)  
Перевод на русский с испанского: **Яша\_Добрый\_Хакер\(Ростовский фанат Нарвахи\).**  
Перевод специально для форума системного и низкоуровневого программирования — **WASM.IN  
01.12.2018  
Версия 1.0**

