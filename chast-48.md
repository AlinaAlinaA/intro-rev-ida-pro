# Часть 48

 Мы будем стараться продолжать обсуждать распределение, чтобы увидеть сможем ли мы понять логику распределения и увидеть, что говорит программа, если распределение происходит в **LFH** или в **СТАНДАРТНОЙ** **КУЧЕ**.  
  
Мы будем продолжать использовать исполняемый файл из того же практического упражнения.  
  
Мы загружаем исполняемый файл вне **IDA** из консоли, не используя скрипт **PYTHON**.  
  
Мы вводим номер, который нас просит программа \(**1073741828\)**, присоединяем **WINDBG** к **IDA** как отладчик, помещаем **BP** на функцию **MALLOC** и нажимаем клавишу **ENTER**.  
  
![1.png](https://wasm.in/attachments/1-png.3465/)   
  
![2.png](https://wasm.in/attachments/2-png.3466/)   
  
Если мы трассируем вход в функцию **MALLOC** с помощью клавиши **F7** мы увидим, что размер помещается в регистр **ESI.** Программа сравнивает это значение. Если размер больше чем значение **0xFFFFFFE0,** то, так как в нашем случае это значение равно **0x10**, то у нас нет проблем. Программа помещает в стек размер как аргумент и прямо там мы видим, что программа помещает в стек, в моём случае, значение **0x240000**. Это одна из куч, поэтому мы уже знаем, что программа будет работать с ней.  
  
![3.png](https://wasm.in/attachments/3-png.3467/)   
  
![4.png](https://wasm.in/attachments/4-png.3468/)   
  
Здесь мы можем создать функцию с помощью правого щелчка и выбрав пункт **CREATE** **FUNCTION** и переименовать аргументы, которые были размером, нулем и базой кучи.  
  
Это структура кучи. Я оставляю её для копирования и вставки.  
  
\# +0x000 Entry : \_HEAP\_ENTRY  
\# +0x008 SegmentSignature : Uint4B  
\# +0x00c SegmentFlags : Uint4B  
\# +0x010 SegmentListEntry : \_LIST\_ENTRY  
\# +0x018 Heap : Ptr32 \_HEAP  
\# +0x01c BaseAddress : Ptr32 Void  
\# +0x020 NumberOfPages : Uint4B  
\# +0x024 FirstEntry : Ptr32 \_HEAP\_ENTRY  
\# +0x028 LastValidEntry : Ptr32 \_HEAP\_ENTRY  
\# +0x02c NumberOfUnCommittedPages : Uint4B  
\# +0x030 NumberOfUnCommittedRanges : Uint4B  
\# +0x034 SegmentAllocatorBackTraceIndex : Uint2B  
\# +0x036 Reserved : Uint2B  
\# +0x038 UCRSegmentList : \_LIST\_ENTRY  
\# +0x040 Flags : Uint4B  
\# +0x044 ForceFlags : Uint4B  
\# +0x048 CompatibilityFlags : Uint4B  
\# +0x04c EncodeFlagMask : Uint4B  
\# +0x050 Encoding : \_HEAP\_ENTRY  
\# +0x058 PointerKey : Uint4B  
\# +0x05c Interceptor : Uint4B  
\# +0x060 VirtualMemoryThreshold : Uint4B  
\# +0x064 Signature : Uint4B  
\# +0x068 SegmentReserve : Uint4B  
\# +0x06c SegmentCommit : Uint4B  
\# +0x070 DeCommitFreeBlockThreshold : Uint4B  
\# +0x074 DeCommitTotalFreeThreshold : Uint4B  
\# +0x078 TotalFreeSize : Uint4B  
\# +0x07c MaximumAllocationSize : Uint4B  
\# +0x080 ProcessHeapsListIndex : Uint2B  
\# +0x082 HeaderValidateLength : Uint2B  
\# +0x084 HeaderValidateCopy : Ptr32 Void  
\# +0x088 NextAvailableTagIndex : Uint2B  
\# +0x08a MaximumTagIndex : Uint2B  
\# +0x08c TagEntries : Ptr32 \_HEAP\_TAG\_ENTRY  
\# +0x090 UCRList : \_LIST\_ENTRY  
\# +0x098 AlignRound : Uint4B  
\# +0x09c AlignMask : Uint4B  
\# +0x0a0 VirtualAllocdBlocks : \_LIST\_ENTRY  
\# +0x0a8 SegmentList : \_LIST\_ENTRY  
\# +0x0b0 AllocatorBackTraceIndex : Uint2B  
\# +0x0b4 NonDedicatedListLength : Uint4B  
\# +0x0b8 BlocksIndex : Ptr32 Void  
\# +0x0bc UCRIndex : Ptr32 Void  
\# +0x0c0 PseudoTagEntries : Ptr32 \_HEAP\_PSEUDO\_TAG\_ENTRY  
\# +0x0c4 FreeLists : \_LIST\_ENTRY  
\# +0x0cc LockVariable : Ptr32 \_HEAP\_LOCK  
\# +0x0d0 CommitRoutine : Ptr32 long  
\# +0x0d4 FrontEndHeap : Ptr32 Void  
\# +0x0d8 FrontHeapLockCount : Uint2B  
\# +0x0da FrontEndHeapType : UChar  
\# +0x0dc Counters : \_HEAP\_COUNTERS  
\# +0x130 TuningParameters : \_HEAP\_TUNING\_PARAMETERS  
  
Мы не будем создавать структуры в **IDA** со всеми полями. Мы только создадим пустую структуру, чтобы переименовывать только те поля, которые мы используем.  
  
![5.png](https://wasm.in/attachments/5-png.3469/)   
  
Я создаю структуру через вкладку **STRUCTURES** с помощью клавиши **INSERT** и затем расширяю её до значения **0x130** байт. Позже я увижу, нужно ли мне расширить её ещё больше.  
  
Мы уже знаем как это сделать. Я добавляю однобайтовое поле, помещая курсор на слово **ENDS** и нажимаю клавишу **D**, а затем нажимаю правую кнопку, и выбираю пункт **EXPAND,** и ввожу значение **0x12F**.  
  
![6.png](https://wasm.in/attachments/6-png.3470/)   
  
![7.png](https://wasm.in/attachments/7-png.3471/)   
  
Я нахожусь в структуре размером **0x130** байт**.** Структура будет немного больше из-за длины последнего поля, но позже мы увидим всё ли правильно.  
  
![8.png](https://wasm.in/attachments/8-png.3472/)   
  
Здесь программа использует смещение **44**, а ниже смещение **5C.** Я нажимаю **T** на обоих полях, и выбираю структуру **HEAP**.  
  
![9.png](https://wasm.in/attachments/9-png.3473/)   
  
Теперь я должен определить эти поля в структуре.  
  
**\# +0x044 FORCEFLAGS : UINT4B**  
\# +0x048 CompatibilityFlags : Uint4B  
\# +0x04c EncodeFlagMask : Uint4B  
\# +0x050 Encoding : \_HEAP\_ENTRY  
\# +0x058 PointerKey : Uint4B  
**\# +0x05C** **INTERCEPTOR : UINT4B**  
  
Это два поля по **4** байты. Я переименую их. Я иду по смещению **0x44** и нажимаю **D** до тех пор пока не появятся буквы **DD**.  
  
![10.png](https://wasm.in/attachments/10-png.3474/)   
  
И я переименую их.  
  
Хорошо. Мы не имеем представление что это и для чего это нужно, но по крайнер мере это выглядит симпатично.  
  
![11.png](https://wasm.in/attachments/11-png.3475/)   
  
Очевидно, не все поля или не всё, что делает программа мы будем интерпретировать, но постепенно мы увидим, что делает программа.  
  
Как только мы дотрассируем до этого места, регистр **EBX** принимает значение базы кучи, **240000** в моем случае. Я могу пойти пойти этому адресу и назначить этому адресу структуру кучи, которая на данный момент что-то имеет.  
  
![12.png](https://wasm.in/attachments/12-png.3476/)   
  
С помощью сочетания **ALT** + **Q** или **CONVERT** **TO** **STRUCT** **VARIABLE** мы можем конвертировать данные в структуру.  
  
![13.png](https://wasm.in/attachments/13-png.3477/)   
  
![14.png](https://wasm.in/attachments/14-png.3478/)   
  
Выглядит не очень симпатично, но там видны поля **FORCEFLAGS** и **INTERCEPTOR** равные нулю.  
  
Это совпадает c результатом отладчика  
  
![15.png](https://wasm.in/attachments/15-png.3479/)   
  
И с помощью такой команды видны значения  
  
![16.png](https://wasm.in/attachments/16-png.3480/)   
  
![17.png](https://wasm.in/attachments/17-png.3481/)  
  
Я скопировал исполняемый файл в другую папки не закрывая предыдущий файл, чтобы проверить его. Я открываю второй файл непосредственно во второй **IDA** без присоединения, но прямо внутри неё и это значение изменяться на **0x40000060.** Это значение, указывает на то отлаживается ли программа.  
  
![18.png](https://wasm.in/attachments/18-png.3482/)   
  
Это вывод для файла, который отлаживается.  
  
![19.png](https://wasm.in/attachments/19-png.3483/)   
  
А это вывод для файла, который просто отрыт в отладчике.  
  
![20.png](https://wasm.in/attachments/20-png.3484/)   
  
Здесь отладчик говорит, что среди прочих вещей, этот флаг может быть использован как **АНТИОТЛАДОЧНАЯ ТЕХНИКА**.  
  
![21.png](https://wasm.in/attachments/21-png.3485/)   
  
Аргумент, который был равен нулю повторно используется в инструкции **OR** с полем **FORCEFLAGS**. Таким образом, поскольку аргумент был равен нулю, это выражение будет также равно **FORCEFLAGS**.  
  
И регистр **ECX,** который содержит переменную **INTERCEPTOR** сохраняет её в переменную **VAR**\_**C,** поэтому я переименовываю эту переменную, хотя я не нашел никаких объяснений для чего она нужна, но позже мы увидим, то что я увидел, это то что переменная не меняется если программа отлаживается или не равна нулю в обоих случаях.  
  
Поскольку переменная **INTERCEPTOR** в моем случае равна нулю и регистр **ESI** равен нулю, программа переходит на красную стрелку так как значения равны.  
  
![22.png](https://wasm.in/attachments/22-png.3486/)   
  
Затем программа тестирует переменную **FORCEFLAGS**, которая равна нулю по отношению к константе **7D810F61.** Результат будет равен нулю и программа будет идти по красной стрелкой. \(Если программа открыта в отладчике, то программа будет идти по зеленой стрелке\)  
  
Программа сравнивает, значения. Если размер равен нулю, а в нашем случае он равен **0x10**, поэтому программа пойдет сюда.  
  
![23.png](https://wasm.in/attachments/23-png.3487/)   
  
Программа прибавляет к регистру **EAX** значение **0xF**, а затем исполняет инструкцию **AND** с параметром **-8**, что будет равно **0x18.** Это будет равно полному размеру, чтобы распределить добавленный заголовок и быть умноженным на **8**.  
  
![24.png](https://wasm.in/attachments/24-png.3488/)   
  
В регистре **EAX** остается значение полного размера**,** равное **18**.  
  
Затем программа сохраняет в переменную **VAR**\_**8** это значение, поэтому я переименую эту переменную.  
  
![25.png](https://wasm.in/attachments/25-png.3489/)   
  
Затем программа читает поле **0xB8** которое является **BLOCKINDEX**, поэтому я переименую его в структуре и здесь я нажимаю **T** для того чтобы освежить информацию.  
  
**\# +0x0B8** **BLOCKSINDEX : PTR32** **VOID**  
  
![26.png](https://wasm.in/attachments/26-png.3490/)   
  
![27.png](https://wasm.in/attachments/27-png.3491/)   
  
Поэтому это значение является указателем, которое равно **0x240150** в моём случае.  
Давайте запомним, что  
  
shr eax, 3 ;Signed division by 8  
  
И это то же самое что и знаковое деление переменной **SIZE\_FULL** на **8.** Помните также, что размер, который появился в заголовках как общий размер, нужно было умножить на **8**, чтобы найти общий размер блока.  
  
Например, скопировав из предыдущего туториала поле **USERSIZE** **0x10**, мы получим общий размер **0x3**, умножив который на **8**, мы получим общее количество байтов.  
  
![28.png](https://wasm.in/attachments/28-png.3492/)   
  
Python&gt;hex\(0x3\*0x8\)  
0x18  
  
Это обратная операция для переменной **SIZE\_FULL** для нахождения значения **0x3** при делении на **0x8**.  
  
![29.png](https://wasm.in/attachments/29-png.3493/)   
  
Мы видим, что теперь программа начинает работать со структурой **BLOCKSINDEX**, которую мы видели в последнем туториале. \(Следующее изображение из предыдущего туториала\)  
  
![30.png](https://wasm.in/attachments/30-png.3494/)   
  
Поэтому мы можем создать новую пустую структуру из **0x24** байт, чтобы ввести последний **DWORD**.  
  
![31.png](https://wasm.in/attachments/31-png.3495/)   
  
Поэтому сейчас я нажимаю **T** на инструкции и выбираю эту новую структуру.  
  
![32.png](https://wasm.in/attachments/32-png.3496/)   
  
Теперь я должен только переименовать поле, которое находится по смещению **0x4** в **ARRAYSIZE**.  
  
Поскольку регистр **EAX** указывает на начало этой структуры, я могу пойти в память и назначить структуру с помощью **ALT** **+** **Q.**  
  
![33.png](https://wasm.in/attachments/33-png.3497/)   
  
**ARRAYSIZE** равен **0x80** в этом случае, остальные поля по-прежнему не определены, поэтому все это выглядит некрасивым.  
  
Поскольку значение **ARRAYSIZE** меньше, программа не идет на розовые блоки.  
  
![34.png](https://wasm.in/attachments/34-png.3498/)   
  
Мы находимся в этой части  
  
![35.png](https://wasm.in/attachments/35-png.3499/)   
  
Здесь **FULL SIZE** делится на **8.** Это значение присваивается переменной **BLOCKSIZE.** Мы все еще храним это значение в регистре **ECX.** Мы не сохраняем его, только сравниваем, и мы видим, что программа также делает, сравнивая с **ARRAYSIZE** так же, как и наши.  
  
Программа вычитает **1** из значения **ARRAYSIZE,** получая значение **0x7F** и снова сравнивает результат со значением **0x3,** которое находится в регистре **ECX**.  
  
![36.png](https://wasm.in/attachments/36-png.3500/)   
  
Поскольку значение продолжает быть меньше, программа не идет на розовые блоки.  
  
Сейчас программа прочитает поле **0x14** структуры **BLOCKLIST**, которое называется **BASEINDEX**, поэтому я переименую его.  
  
![37.png](https://wasm.in/attachments/37-png.3501/)   
![38.png](https://wasm.in/attachments/38-png.3502/)   
  
Поскольку **BASEINDEX** равен **0**, регистр **ECX** по-прежнему продолжает быть равен значению **0x3** т.е. **BLOCKSIZE.**  
  
![39.png](https://wasm.in/attachments/39-png.3503/)   
  
Поскольку поле **EXTRAITEM**, которое находится по смещению **0x8**, равно **1** \(я не буду повторять, как переименовать поле в структуре\), мы доходим до инструкции **ADD** **ECX**, **ECX**, где программа умножает на **2** значение **BLOCKSIZE**.  
  
![40.png](https://wasm.in/attachments/40-png.3504/)   
  
Затем программа использует смещение **0x20** **LISTHINTS**.  
  
![41.png](https://wasm.in/attachments/41-png.3505/)   
  
При умножении **0x6** на **4** и сложение с указателем **LISTHINTS** в регистре **ESI** остаётся значение **0x24019C**.  
  
![42.png](https://wasm.in/attachments/42-png.3506/)   
  
**LISTHINTS** указывает на **FREELIST**, который является другим типом более простого распределения. Теперь мы посмотрим, что делает программа.  
  
![43.png](https://wasm.in/attachments/43-png.3507/)   
  
Таким образом, мы можем создать новую структуру из **8** байт. Но в моей **IDA** у меня уже это есть эта структура \(если у вас её нет, то создайте её\).  
  
![44.png](https://wasm.in/attachments/44-png.3508/)   
  
![45.png](https://wasm.in/attachments/45-png.3509/)   
  
Т.е. если **LFH** выключен, у **BLINK** есть счетчик, а если он включен, то имеет указатель. \(**HEAP**\_**BUCKET + 1**\)  
  
Хорошо. Вопрос здесь состоит в том, что программа тестирует регистр **AL.** Если он равен **1**, чтобы увидеть, является ли он счетчиком.  
  
![46.png](https://wasm.in/attachments/46-png.3510/)   
  
Если **BLINK** равен **1**, программа переходит к этому зеленому блоку с вызовом функции **RTLPALLOCATEHEAP**, а если нет, как в моем случае, программа переходит на голубой блок, который идет в вызов **RTLPLOWFRAGHEAPALLOCFRONCONTEXT**.  
  
Другими словами, есть некоторые вещи, которые мы видим в нашем случае, программа сравнивает размер **0x3** с **0x80,** и поскольку это значение меньше, а регистр **AL** из **BLINK** отличался от байта **0x1**, мы прибыли сюда к чему-то, что, по-видимому, обрабатывается **LFH.**  
  
![47.png](https://wasm.in/attachments/47-png.3511/)   
![48.png](https://wasm.in/attachments/48-png.3512/)   
  
Регистр **ECX** имеет указатель, который был в **BLINK** - **1** и в регистре **EDX** находится **USERSIZE** **0x10**.  
  
![49.png](https://wasm.in/attachments/49-png.3513/)   
  
Поскольку в функции не отображаются переменные и функция основана на **EBP** \(были переменными **EBP** - **X**\), я изменил тип функции, поставив здесь галочку.  
  
Напомним, что у **BLINK** было значение **HEAP\_BUCKET** **+** **1**, другими словами, вычитая **1**, это будет равно **HEAP\_BUCKET**, поэтому я переименую переменную в **HEAP\_BUCKET**.  
  
![50.png](https://wasm.in/attachments/50-png.3514/)   
  
![51.png](https://wasm.in/attachments/51-png.3515/)   
  
Другими словами, регистр **EDI** является базой структуры **HEAP**\_**BUCKET** которую я создал.  
  
Кажется она имеет **0x3** байта.  
  
![52.png](https://wasm.in/attachments/52-png.3516/)   
  
Хорошо. **SIZEINDEX** равен **2,** программа помещает это значение в регистр **EAX** ![1.png](https://wasm.in/attachments/1-png.3522/)   
  
**LEA** **EAX, DS:110H\[EAX\*4\]**  
  
Программа умножает значение **0x2** на **4** и складывает полученное значение со значением **0x110** и затем вычитает из найденного значения **HEAP\_BUCKET** и сохраняет результат в переменную **VAR\_2C**.  
  
Этот адрес, который сохраняется в переменную **VAR\_2C** является началом таблицы **LFH**, так как **HEAP\_BUCKETS** находится по смещению **0x110** и должен быть равен **8**, потому что поле находится внутри таблицы **BUCKETS**, поэтому в переменной **VAR\_2C** программа сохраняет значение **0x24ACF8**, которое было началом таблицы **LFH**.  
  
![2.png](https://wasm.in/attachments/2-png.3523/)   
  
![3.png](https://wasm.in/attachments/3-png.3524/)   
  
![4.png](https://wasm.in/attachments/4-png.3525/)   
  
То, что программа сейчас делает, это то, что говорит нам картинка. Программа пытаясь найти адрес **LFH** для этой структуры **BUCKET**, используя переменную **SIZEINDEX**.  
  
![5.png](https://wasm.in/attachments/5-png.3526/)   
  
![6.png](https://wasm.in/attachments/6-png.3527/)   
  
Очевидно, мы находимся в этой части, только в моём случае переменная не равна единице и программа продолжает выполнение здесь.  
  
![7.png](https://wasm.in/attachments/7-png.3528/)   
  
![8.png](https://wasm.in/attachments/8-png.3529/)   
  
Программа достигает инструкции **LEA**, где на данный момент регистр **EAX** равен нулю, поскольку он получается из умножения **0x3418** на **CONST\_CERO** и суммируется с регистром **ESI**, который хранит начало таблицы **LFH** и добавляет значение **0x310**.  
  
![9.png](https://wasm.in/attachments/9-png.3530/)   
  
Мы напомним, что смещение **0x310** из **LFH** это \_**HEAP**\_**LOCAL**\_**DATA**.  
  
![10.png](https://wasm.in/attachments/10-png.3531/)   
  
Это значение сохраняется в переменную **VAR\_44**. Я переименую это поле в **HEAP**\_**LOCAL**\_**DATA**.  
  
![11.png](https://wasm.in/attachments/11-png.3532/)   
  
![12.png](https://wasm.in/attachments/12-png.3533/)   
  
![13.png](https://wasm.in/attachments/13-png.3534/)   
  
Основная идея состоит в том, что мы пытаемся найти эти структуры и увидим, можем ли мы их найти и идентифицировать.  
  
Хорошо. Мы должны создать структуру для **HEAP**\_**LOCAL**\_**DATA**.  
  
![14.png](https://wasm.in/attachments/14-png.3535/)   
  
Я создаю структуру из **0x22** байт, хотя она наверняка будет намного больше, но пока пойдет и это.  
  
По смещению **0x18** есть структуры. Их размер равен **0x128** байт.  
  
\[128\] \_HEAP\_LOCAL\_SEGMENT\_INFO  
  
Программа проходит через все эти **128** структур, используя **SIZEINDEX** как индекс, который умножается на **0x68**, а затем добавляет значение, чтобы найти адрес это структуры **SEGMENTINFO**.  
  
![15.png](https://wasm.in/attachments/15-png.3536/)   
  
Это означает, что адрес **DIRECCION3** равен **HEAP\_LOCAL\_SEGMENT\_INFO**.  
  
![16.png](https://wasm.in/attachments/16-png.3537/)   
  
![17.png](https://wasm.in/attachments/17-png.3538/)   
  
Поэтому мы будем создавать структуру больше чем **0x64** байта.  
  
![18.png](https://wasm.in/attachments/18-png.3539/)   
  
![19.png](https://wasm.in/attachments/19-png.3540/)   
  
Хорошо. Внутри отладчика этого выглядит так.  
  
ntdll!\_HEAP\_LOCAL\_SEGMENT\_INFO  
+0x000 Hint : Ptr32 \_HEAP\_SUBSEGMENT  
  
Первое поле, которое программа пытается использовать здесь, говорит, что это **HINT** .  
  
![20.png](https://wasm.in/attachments/20-png.3541/)   
  
И программа сохранит это значение в переменную **VAR\_30.** Я переименовываю переменную в **HINT**.  
  
![21.png](https://wasm.in/attachments/21-png.3542/)   
  
Если значение **HINT** не равно нулю, программа ищет **ACTIVESUBSEGMENT**, что является следующим полем.  
  
![22.png](https://wasm.in/attachments/22-png.3543/)   
  
А если это поле равно нулю, программа переходит сюда  
  
![23.png](https://wasm.in/attachments/23-png.3544/)   
  
В любом из трех случае, программа сохраняет результат в переменной, которую мы назвали **HINT,** но она может быть любой из трех.  
  
![68.png](https://wasm.in/attachments/68-png.3593/)   
  
Хорошо. Мы находимся здесь.  
  
![24.png](https://wasm.in/attachments/24-png.3545/)   
  
Мы будем переименовывать переменную **HINT** в **RESULTADO**, поскольку переменная может принимать три значения.  
  
![25.png](https://wasm.in/attachments/25-png.3546/)   
  
Картинка показывает нам три варианта. Сейчас же мы находимся в **HINT**.  
  
Этот результат должен был бы быть **\_HEAP\_SUBSEGMENT**.  
  
![26.png](https://wasm.in/attachments/26-png.3547/)   
  
![27.png](https://wasm.in/attachments/27-png.3548/)   
  
Здесь программа говорит мне, что **\_HEAP\_LOCAL\_SEGMENT\_INFO** находится в памяти по адресу **0x24B0F0** и что **0x282660** это структура **\_HEAP\_USERDATA\_HEADER** а по смещению **0x08** это структура **INTERLOCK**\_**SEQ**.  
  
Мы уже подходим к концу. Фууууууууууууууууууххххххххххххх.  
  
Здесь я добавляю новую структуру.  
  
![28.png](https://wasm.in/attachments/28-png.3549/)   
  
![29.png](https://wasm.in/attachments/29-png.3550/)   
  
Здесь я вижу, что программа находит с помощью инструкции **LEA** адрес поля **\_INTERLOCK\_SEQ**  
  
![30.png](https://wasm.in/attachments/30-png.3551/)   
  
![31.png](https://wasm.in/attachments/31-png.3552/)   
  
На данный момент, я думаю что она состоит из **4** байтов.  
  
Программа может прочитать поле как **WORD** или как **DWORD**, это сложно для имени. В моем случае, программа читает **DWORD** т.е. имеет значение **0x56000D** \(**ЭТО** **ЗНАЧЕНИЕ** **ОЧЕНЬ** **ВАЖНО**\)  
  
![32.png](https://wasm.in/attachments/32-png.3553/)   
  
![33.png](https://wasm.in/attachments/33-png.3554/)   
  
![34.png](https://wasm.in/attachments/34-png.3555/)   
  
Я добавляю поле **SEQUENCE.**  
  
![35.png](https://wasm.in/attachments/35-png.3556/)   
  
Программа тестирует регистр **DI** который хранит поле **OFFSETANDDEPTH.** Это поле в моём случае равно **0xD**.  
  
![36.png](https://wasm.in/attachments/36-png.3557/)   
  
Здесь программа читает поле **USERBLOCKS**, которое находится по смещению **0x4** структуры **HEAP\_SUBSEGMENT**.  
  
![37.png](https://wasm.in/attachments/37-png.3558/)   
  
Программа сравнивает регистр **EDX** который хранит **LOCALINFO** высчитанный с помощью указателя **HEAP\_SUBSEGMENT.LOCALINFO** и они должны быть одинаковыми.  
  
Поскольку значения одинаковые, программа идет к этому блоку.  
  
![38.png](https://wasm.in/attachments/38-png.3559/)   
  
![39.png](https://wasm.in/attachments/39-png.3560/)   
  
Хорошо. Я не собираюсь просчитывать все эти значения, но очевидно, что то, что программа делает, это получает первый свободный блок запрошенного размера из значений структуры **\_INTERLOCK\_SEQ**, и когда программа покинет этот блок, она сохранит его здесь.  
  
![40.png](https://wasm.in/attachments/40-png.3561/)   
  
Регистр **ECX** здесь равен значению **282918** и если я посмотрю список блоков с размером **0x10** с помощью команды.  
  
!heap -flt s 0x10  
  
В выводе блоки находятся здесь  
  
![41.png](https://wasm.in/attachments/41-png.3562/)   
  
И это первое значение из этих **LFH**, потому что предыдущие размеры **0x10**, которые говорят что они **FREE\(СВОБОДНЫЕ\)**, имеют другую **LFH** младшего адреса, возможно, соответствующей другой куче.  
  
![42.png](https://wasm.in/attachments/42-png.3563/)   
  
Здесь по адресу чанка **0x282918** без заголовка, вычитается **8**, и остается адрес полного блока с заголовком **0x282910**.  
  
![43.png](https://wasm.in/attachments/43-png.3564/)   
  
Структура, которую мы ещё не добавили называется структурой **LFH**. Сейчас я сделаю это.  
  
![44.png](https://wasm.in/attachments/44-png.3565/)   
  
![45.png](https://wasm.in/attachments/45-png.3566/)   
  
Теперь используется поле **0x24**, которое должно найти базовый адрес **КУЧИ** по адресу **0x240000.** Полученное значение помещается в регистр **ESI**.  
  
![46.png](https://wasm.in/attachments/46-png.3567/)   
  
**BLOCKUNITS** был равен **0x3** в инструкции **SHL** **EAX**, **3**  
  
Это похоже на умножение **8** поэтому  
  
![47.png](https://wasm.in/attachments/47-png.3568/)   
  
И это то значение, что осталось в поле **USERSIZE**  
  
![48.png](https://wasm.in/attachments/48-png.3569/)   
  
И это значение программа сравнивает со значением **0x3F** . Поскольку оно меньше, программа идёт сюда.  
  
![49.png](https://wasm.in/attachments/49-png.3570/)   
  
Здесь программа пишет в заголовок чанка **LFH.** Мы не сделали структуру.  
  
![50.png](https://wasm.in/attachments/50-png.3571/)   
  
![51.png](https://wasm.in/attachments/51-png.3572/)   
  
![52.png](https://wasm.in/attachments/52-png.3573/)   
  
Программа перезаписывает **7** байт, меняя его со значения **0x80** на **0x88.**  
  
![53.png](https://wasm.in/attachments/53-png.3574/)   
  
![54.png](https://wasm.in/attachments/54-png.3575/)   
  
Сейчас блок обозначен как занятый. Если мы посмотрим следующий свободный блок по адресу **282928**  
  
![55.png](https://wasm.in/attachments/55-png.3576/)   
  
Свободные блоки - это блоки со значение **0x80** , а занятые со значением **0x88**.  
  
![56.png](https://wasm.in/attachments/56-png.3577/)   
  
Вопрос состоит в том, что значение, которое находится в структуре **INTERLOCK**\_**SEQ** и которое определяет следующий блок для доставки находится в по адресу **0x282A78** \(по смещению **0x8** от начала структуры **HEAP**\_**SUBSEGMENT**\)  
  
До этого значение было равно **56000D.**  
  
![57.png](https://wasm.in/attachments/57-png.3578/)   
  
А сейчас значение равно **59000C.**  
  
![58.png](https://wasm.in/attachments/58-png.3579/)   
  
![59.png](https://wasm.in/attachments/59-png.3580/)   
  
Расстояние между началом чанка, в который я могу написать, который решает, кто следующий….  
  
![60.png](https://wasm.in/attachments/60-png.3581/)   
  
То, что мы сказали в предыдущем туториале проверено здесь.  
  
![61.png](https://wasm.in/attachments/61-png.3582/)   
  
Это значение **0x282660 USERBLOCKS,** помещается в регистр **ESI.**  
  
![62.png](https://wasm.in/attachments/62-png.3583/)   
![63.png](https://wasm.in/attachments/63-png.3584/)   
  
Это означает, что в следующий раз, когда запрашивается размер **0x010**, программа поместит в **EDI** значение **0x59000C** если оно не перезаписано.  
  
Программа помещает значение в регистр **EAX** и затем исполняет инструкцию **SHR** **EAX**,**0xD  
  
2** в **0xD** степени = **8192** десятичных байт, т.е. **0x2000** в шестнадцатеричной системе  
  
Другими словами, это эквивалентно значению **0x59000С** делённому на значение **0x2000**, что даёт мне результат **0x2C8**  
  
![64.png](https://wasm.in/attachments/64-png.3585/)   
  
К этому значению программа применяет инструкцию **AND** c параметром **0x7FFF8**  
  
![65.png](https://wasm.in/attachments/65-png.3586/)   
  
Затем программа добавляет регистр **ESI**, который равен **0x282660**  
  
![66.png](https://wasm.in/attachments/66-png.3587/)   
  
И это даём мне результат **0x282928**, что является следующим свободным  
  
![67.png](https://wasm.in/attachments/67-png.3588/)   
  
Это означает, что если есть переполнение, мы можем перезаписать эти данные переписав значение внутри структуры **INTERLOCK\_SEQ** и программа предоставит мне предыдущий блок, про который мы расскажем в следующей части.  
  
**=======================================================  
Автор текста: Рикардо Нарваха** - **Ricardo** **Narvaja** \(**@ricnar456**\)  
Перевод на русский с испанского: **Яша\_Добрый\_Хакер\(Ростовский фанат Нарвахи\).  
Исправление ошибок и неточностей - репетитор и носитель испанского языка.**  
Перевод специально для форума системного и низкоуровневого программирования — **WASM.IN  
24.06.2018  
Версия 1.0**

