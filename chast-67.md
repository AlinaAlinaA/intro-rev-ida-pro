# Часть 67

 **Метод, который мы не рассмотрели, чтобы эксплуатировать одну из уязвимостей драйвера HACKSYS.**  
  
Мой друг попросил у меня несколько разъяснений о методе, используемом для обхода **COOKIE** на **32**-битных машинах, когда у нас есть переполнение стека в ядре, и мы можем перезаписать адрес возврата, но есть **COOKIE**, который мешает нам завершить выполнение кода.  
  
Очевидно, что если у нас есть другая уязвимость, которая допускает утечку данных, мы могли бы прочитать значение **COOKIE** и затем использовать его для отправки наших данных, для перезаписи, но есть метод, который я никогда не использовал на практике, который немного стар и в системах, отличных от **WINDOWS** **7** **32** бит не будет работать, но было бы хорошо взглянуть на него, чтобы уточнить для моего друга и того, кто читает меня \(и для меня самого\).  
  
Мы уже знаем, что уязвимый драйвер можно скачать отсюда.  
  
[https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/releases/download/v1.20/HEVD.1.20.zip](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/releases/download/v1.20/HEVD.1.20.zip)  
  
А сам инструмент для загрузки драйвера, можно загрузить отсюда.  
  
[http://www.osronline.com/OsrDown.cfm/osrloaderv30.zip?name=osrloaderv30.zip&id=157](http://www.osronline.com/OsrDown.cfm/osrloaderv30.zip?name=osrloaderv30.zip&id=157)  
  
Прежде чем скопировать драйвер в целевую машину, мы откроем его в загрузчике **IDA** для его анализа.  
  
Внутри **ZIP** архива находятся такие файлы.  
  
**HEVD.1.20\DRV\VULNERABLE\I386**  
  
![1.png](https://wasm.in/attachments/1-png.5425/)   
  
Это драйвер и его символы.  
  
![2.png](https://wasm.in/attachments/2-png.5426/)   
  
При открытии драйвера в **IDA**, мы видим функцию **DRIVERENTRY**, первым аргументом которой всегда является указатель на объект **\_DRIVER\_OBJECT**.  
  
![3.png](https://wasm.in/attachments/3-png.5427/)   
  
Регистр **ESI** это указатель на объект **\_DRIVER\_OBJECT**.  
  
Если мы перейдём во вкладку **LOCAL** **TYPES**.  
  
![4.png](https://wasm.in/attachments/4-png.5428/)   
  
Мы видим, что эта структура. Если мы поищем структуру **\_IRP**, мы находим наиболее часто используемым для обращения структуры.  
  
![5.png](https://wasm.in/attachments/5-png.5429/)   
  
Мы будем отмечать структуры **\_DRIVER\_OBJECT**, **\_IRP**, **\_DEVICE\_OBJECT**, **\_IO\_STACK\_LOCATION** и **PIRP** и синхронизировать их, потому что именно их мы будем использовать чаще всего.  
  
То что нам нужно сделать - это добавить структуру **MAJORFUNCTION**, которой нигде нет.  
  
Напомним, что мы можем добавить структуру через вкладку **LOCAL** **TYPES**, используя правую кнопку мыши, пункт **INSERT** и вставить этот код.  
  
struct \_\_MajorFunction  
{  
SIZE\_T \_MJ\_CREATE;  
SIZE\_T \_MJ\_CREATE\_NAMED\_PIPE;  
SIZE\_T \_MJ\_CLOSE;  
SIZE\_T \_MJ\_READ;  
SIZE\_T \_MJ\_WRITE;  
SIZE\_T \_MJ\_QUERY\_INFORMATION;  
SIZE\_T \_MJ\_SET\_INFORMATION;  
SIZE\_T \_MJ\_QUERY\_EA;  
SIZE\_T \_MJ\_SET\_EA;  
SIZE\_T \_MJ\_FLUSH\_BUFFERS;  
SIZE\_T \_MJ\_QUERY\_VOLUME\_INFORMATION;  
SIZE\_T \_MJ\_SET\_VOLUME\_INFORMATION;  
SIZE\_T \_MJ\_DIRECTORY\_CONTROL;  
SIZE\_T \_MJ\_FILE\_SYSTEM\_CONTROL;  
SIZE\_T \_MJ\_DEVICE\_CONTROL;  
SIZE\_T \_MJ\_INTERNAL\_DEVICE\_CONTROL;  
SIZE\_T \_MJ\_SCSI;  
SIZE\_T \_MJ\_SHUTDOWN;  
SIZE\_T \_MJ\_LOCK\_CONTROL;  
SIZE\_T \_MJ\_CLEANUP;  
SIZE\_T \_MJ\_CREATE\_MAILSLOT;  
SIZE\_T \_MJ\_QUERY\_SECURITY;  
SIZE\_T \_MJ\_SET\_SECURITY;  
SIZE\_T \_MJ\_POWER;  
SIZE\_T \_MJ\_SYSTEM\_CONTROL;  
SIZE\_T \_MJ\_DEVICE\_CHANGE;  
SIZE\_T \_MJ\_QUERY\_QUOTA;  
SIZE\_T \_MJ\_SET\_QUOTA;  
SIZE\_T \_MJ\_PNP;  
SIZE\_T \_MJ\_PNP\_POWER;  
SIZE\_T \_MJ\_MAXIMUM\_FUNCTION;  
};  
![6.png](https://wasm.in/attachments/6-png.5430/)   
  
Мы добавляем и синхронизируем структуру, и последнее что мы делаем – открываем во вкладке **LOCAL** **TYPES** структуру **\_DRIVER\_OBJECT** и изменяем ее так, чтобы последнее поле представляло собой структуру типа **\_MAJORFUNCTION**.  
  
![7.png](https://wasm.in/attachments/7-png.5431/)   
  
Мы видим, что изначально это массив указателей на функции, но если мы изменим его на структуру с указателями на известные функции с их именами, это будет проще и будет работать так же, и это даст нам информацию, которая нам необходима в более четкой форме.  
  
![8.png](https://wasm.in/attachments/8-png.5432/)   
  
Таким образом, вместо того, чтобы был массивом указателей на функции, про которые мы ничего не знаем, что делает каждая из них, это будет структура той же длины, что и массив, но с указателями на функции, уже известные в соответствии со спецификацией.  
  
Мы видим, что регистр **ESI** сохраняет значение указателя на объект **\_DRIVER\_OBJECT** в этой области, а по адресу **0x000160СF** и это значение указателя затирается.  
  
![9.png](https://wasm.in/attachments/9-png.5433/)   
  
Таким образом, мы помечаем эту зону \(это можно сделать с помощью **ALT + L**, спустится стрелкой курсора и затем снова нажать **ALT + L** для завершения\) или если это небольшая область сделать это той же мышью.  
  
![10.png](https://wasm.in/attachments/10-png.5434/)   
  
Как только зона отмечена, мы нажимаем **T**.  
  
![11.png](https://wasm.in/attachments/11-png.5435/)   
  
Конечно, мы выбираем регистр **ESI** в качестве базового регистра структуры и смещение, которое мы устанавливаем в нуль, потому что оно указывает на начало структуры, и мы выбираем структуру **\_DRIVER\_OBJECT**, и **IDA** обнаруживает **4** поля которые используются.  
  
![12.png](https://wasm.in/attachments/12-png.5436/)   
  
Для нас важно то поле, которое обрабатывает **IOCTL**, т.е. **\_MJ\_DEVICE\_CONTROL**.  
  
Если бы у нас не было символов, такая же работа выполнялась бы путем импорта файла **.H** с **32**-битными структурами для реверсинга драйверов.  
  
Файл **.H** с 32-битными структурами находится здесь.  
  
[https://drive.google.com/file/d/1VXwR45uvw1FtvzW2b9eNO1DLid9CIdx8/view?usp=sharing](https://drive.google.com/file/d/1VXwR45uvw1FtvzW2b9eNO1DLid9CIdx8/view?usp=sharing)  
  
И он импортируется в **IDA** отсюда.  
  
![13.png](https://wasm.in/attachments/13-png.5437/)   
  
При этом мы увидим необходимые структуры **DRIVER\_OBJECT**, **\_IRP**, **\_DEVICE\_OBJECT**, **\_IO\_STACK\_LOCATION** и **PIRP** и **\_MAJORFUNCTION** в **LOCAL** **TYPES**. Мы синхронизируем их и получим таким же образом возможность распознавать функцию, которая обрабатывает **IOCTL**.  
  
В этом случае, наличие символов для этой функции уже имело имя, что дало нам представление о том, что это искомая функция, но по мере того, как мы учимся, полезно знать это всё, чтобы найти ее для всех случаев реверсинга, либо с символами, либо без символов.  
  
![14.png](https://wasm.in/attachments/14-png.5438/)   
  
Внутри этой функции, которая обрабатывает **IOCTL**, находятся различные уязвимые функции. В этом случае мы будем пытаться эксплуатировать функцию **STACKOVERFLOWG**.  
  
![15.png](https://wasm.in/attachments/15-png.5439/)   
  
Вызов идет сюда.  
  
![16.png](https://wasm.in/attachments/16-png.5440/)   
  
И затем сюда.  
  
Мы видим, что есть функция **MEMCPY**, которая копирует буфер в стек. **MAXCOUNT** - количество байтов. Полностью отреверсив функцию мы увидим, что у неё есть **COOKIE.** Хотя мы это уже видели до адреса возврата, который в отличие от другого переполнения стека, который мы уже эксплуатировали.  
  
![17.png](https://wasm.in/attachments/17-png.5441/)   
  
Перед инструкцией **RETN** есть такой вызов.  
  
![18.png](https://wasm.in/attachments/18-png.5442/)   
  
Эта проверка и в начале функции она то же есть.  
  
![19.png](https://wasm.in/attachments/19-png.5443/)   
  
Возвращаясь к началу функции с именем **IRPDEVICEIOCTLHANDLER**, которая обрабатывает **IOCTL**, в регистре **EDI** передается указатель на структуру **IRP**. Мы уже видели в предыдущих туториалах, что в **32х** битных системах по смещению **0x60** это был указатель на структуру **IO\_STACK\_LOCATION**, которая останется в регистре **ESI**.  
  
И я нажимаю **T** на **ESI** + **0xC**.  
  
![20.png](https://wasm.in/attachments/20-png.5444/)   
  
Как мы уже видели, что структура **IO\_STACK\_LOCATION** варьируется в зависимости от функции, в которой она используется , поскольку здесь мы используем её в случае функции, которая обрабатывает **IOCTL**. Мы должны выбрать **DEVICEIOCONTROL**.  
  
![21.png](https://wasm.in/attachments/21-png.5445/)   
  
Я оставлю всё это так. В этой функции, регистр **ESI** имеет указатель на **IO\_STACK\_LOCATION**, регистр **EDX** – это код **IOCTL** \(**IOCONTROLCODE**\) и **EDI** указатель на **\_IRP**.  
  
![22.png](https://wasm.in/attachments/22-png.5446/)   
  
Регистр **ESI** и регистр **EDI –** это два аргумента вызова функции **STACKOVERFLOWGSIOCTLHANDLER**.  
  
![23.png](https://wasm.in/attachments/23-png.5447/)   
  
Конечно, поскольку у нас есть символы, мы можем видеть эти два аргумента в определении функции. Первый - это указатель на **\_IRP**, а второй - указатель на **IO\_STACK\_LOCATION**.  
  
![24.png](https://wasm.in/attachments/24-png.5448/)   
  
Опять же, пытаясь определить поле **\_IO\_STACK\_LOCATION**, мы должны выбрать случай, когда используется **DEVICEIOCONTROL**.  
  
![25.png](https://wasm.in/attachments/25-png.5449/)   
  
Мы видим, что то, что мы определили при реверсинге, совпадает с тем, что нам показывают символы.  
  
![26.png](https://wasm.in/attachments/26-png.5450/)   
  
Поле **INPUTBUFFERLENGHT** - это размер входного буфера из режима пользователя, а **TYPE3INPUTBUFFER** - указатель на этот пользовательский входной буфер, который мы также передаем.  
  
Переименуем эти два аргумента. Помните, что та переменная, которую мы называем **SIZE\_BUFFER\_USER**, является произвольным переданным нами числом, которое должно быть размером буфера, но это может быть любое значение, так как не видно никакой проверки.  
  
![27.png](https://wasm.in/attachments/27-png.5451/)   
  
Мы видим, что обе переменные используются без проверки или изменения в функции **MEMCPY.**  
  
![28.png](https://wasm.in/attachments/28-png.5452/)   
  
Назначением функции **MEMCPY** является буфер в стеке, который мы можем перезаписать. Проблема в том, что здесь функция не помогает нам перезаписать весь стек, пока он не закончится, потому что в этом случае **SEH** не вызывается так, как в пользовательском режиме, и создается **BSOD**, поэтому необходимо использовать другую технику.  
  
![29.png](https://wasm.in/attachments/29-png.5453/)   
  
![30.png](https://wasm.in/attachments/30-png.5454/)   
  
Инициализируется только **0x1FF** байт буфера. Также нет проблем, что некоторые байты ещё остались нетронутыми.  
  
![31.png](https://wasm.in/attachments/31-png.5455/)   
  
В начале функции мы видим, что выше адреса возврата есть структура **CPPEH\_RECORD**.  
  
![32.png](https://wasm.in/attachments/32-png.5456/)   
  
Она находится чуть ниже буфера и поверх адреса возврата.  
  
![33.png](https://wasm.in/attachments/33-png.5457/)   
  
Мы видим, что в стек помещаются два аргумента. Константа **0x210** и указатель на структуру. Константа **0x210**, так как это первый **PUSH**, будет чуть выше адреса возврата **R**, который я сохранил при входе в эту же функцию пролога.  
  
![34.png](https://wasm.in/attachments/34-png.5458/)   
  
Однако мы видим, что **IDA** показывает нам, что чуть выше "**R**" находится сохраненный регистр **EBP** т.е. "**S**".  
  
![35.png](https://wasm.in/attachments/35-png.5459/)   
  
Также, если мы войдем в функцию **\_\_SEH\_PROLOG4\_GS**.  
  
![36.png](https://wasm.in/attachments/36-png.5460/)   
  
Мы видим, что после помещения в регистр **EAX** значения переменной **CONS\_0x210**, программа сохраняет здесь регистр **EBP**, так что на самом деле выше "**R**" , наконец, остается "**S**" или сохраненный регистр **EBP**.  
  
Затем, над сохраненным регистром **EBP**, помещается указатель на эту структуру которая передается сразу после инструкции **PUSH** **0x210**.  
  
![37.png](https://wasm.in/attachments/37-png.5461/)   
  
По этому адресу находится структура **STRU\_0x12218.** Программа сохраняет её чуть выше "**S**".  
  
![38.png](https://wasm.in/attachments/38-png.5462/)   
  
И чуть выше “**S**” находится переменная **MS\_EXC**, которая является структурой типа **CPPEH\_RECORD**, так что этот адрес будет последним полем этой структуры, и мы увидим это.  
  
![39.png](https://wasm.in/attachments/39-png.5463/)   
  
Здесь после сохранения сохраненного регистра **EBP** в переименую **CONST\_0X210** программа помещает адрес указанной переменной в регистр **EBP**. Это будет более или менее похоже на начало функции **PUSH** **EBP**, **MOV** **EBP**, **ESP**.  
  
Оба должны сохранить значение регистра **EBP** родительской функции **TRIGGERSTACKOVERFLOWGS** и установить новый регистр **EBP** для неё через инструкцию **LEA**.  
  
![40.png](https://wasm.in/attachments/40-png.5464/)   
  
Затем программа освобождает место для переменных, выполняя инструкцию **SUB** **ESP**, **EAX.**  
  
И также мы видим, что по адресу **EBP-4** **XOR**ится значение, которое было там с **COOKIE**, которое читается из секции данных.  
  
Напомним, что по адресу **EBP-4** находится значение **0x12218**. С этим значением **XOR**ится **COOKIE** и сохраняется по этому адресу.  
  
![41.png](https://wasm.in/attachments/41-png.5465/)   
  
Кроме того, **XOR**ится **COOKIE** с регистром **EBP** и полученное значение сохраняется по адресу **EBP-1C**.  
  
![42.png](https://wasm.in/attachments/42-png.5466/)   
  
Это то, что программа будет проверять в эпилоге.  
  
![43.png](https://wasm.in/attachments/43-png.5467/)   
  
И внутри функции **\_\_SECURITY\_CHECK\_COOKIE**.  
  
![44.png](https://wasm.in/attachments/44-png.5468/)   
  
Программа сравнивает значения. Если они одинаковы, то всё хорошо, а если нет мне выкидывает **BSOD**.  
  
Мы создадим стек с самого начала в соответствии с порядком, с которым программа размещает значения перед входом в пролог:  
  
**PUSH 0x210  
PUSH 0x12218**  
  
Затем программа входит в пролог, который заставляет её сохранять адрес возврата в стеке, куда она будет возвращаться. Это будет адрес **0x000148E9**, поскольку при выходе из пролога программа вернется туда.  
  
![45.png](https://wasm.in/attachments/45-png.5469/)   
  
Таким образом, при входе в пролог мы имеем в стеке два аргумента и адрес возврата, куда вернется программа.  
  
![46.png](https://wasm.in/attachments/46-png.5470/)   
  
Давайте продолжим смотреть на то, как аргументы помещаются в стек.  
  
Затем есть еще две инструкции **PUSH -** адрес функции **EXCEPTION\_HANDLER4** и значение, которое содержит регистр **FS:0.**  
  
![47.png](https://wasm.in/attachments/47-png.5471/)   
  
Над обратным адресом тогда будут эти два значения.  
  
![48.png](https://wasm.in/attachments/48-png.5472/)   
  
Затем **0x210** перезаписывается **STORED\_EBP**.  
  
![49.png](https://wasm.in/attachments/49-png.5473/)   
  
Мы знаем, что под сохраненным регистром **EBP** был адрес возврата в функцию **TRIGGERSTACKOVERFLOWGS**. Мы добавили его в наше представление стека.  
  
![50.png](https://wasm.in/attachments/50-png.5474/)   
  
Текущий регистр **EBP** остается с адресом **STORE\_EBP** \(смотри на адрес, а не значение\)  
  
Из регистра **ESP** вычитается значение **0x210** для пространства переменных, другими словами над адресом **FS:0** - **0x210** останется регистр **ESP**.  
  
![51.png](https://wasm.in/attachments/51-png.5475/)   
  
Затем выше есть еще три **PUSH** - **EBX**, **ESI** и **EDI**.  
  
![52.png](https://wasm.in/attachments/52-png.5476/)   
  
![53.png](https://wasm.in/attachments/53-png.5477/)   
  
Затем содержимое **EBP-4** **XOR**ится с **COOKIE**.  
  
Поскольку **ТЕКУЩИЙ** **EBP** продолжает указывать на адрес **STORE\_EBP**, **EBP-4** указывает на значение **0x12218**, это значение **XOR**ится с **COOKIE**.  
  
**ЗНАЧЕНИЕ EBX  
ЗНАЧЕНИЕ ESI  
ЗНАЧЕНИЕ EDI**  
…  
…  
…  
**FS:0  
\_\_EXCEPT\_HANDLER4  
0x148E9 &lt;---- АДРЕС ВОЗВРАТА В ПРОЛОГ  
0x12218 &lt;--------XORится с COOKIE  
STORED\_EBP &lt;----- ТЕКУЩИЙ EBP - АДРЕС STORED\_EBP  
АДРЕС ВОЗВРАТА В ФУНКЦИЮ TriggerStackOverflowGS**  
  
Если мы сделаем так, чтобы уточнить первый столбец, с адресами ссылающимися на значение **ТЕКУЩЕГО** **EBP**.  
  
**ЗНАЧЕНИЕ EBX  
ЗНАЧЕНИЕ ESI  
ЗНАЧЕНИЕ EDI**  
…  
…  
…  
**EBP-10 FS:0  
EBP-C \_\_EXCEPT\_HANDLER4  
EBP-8 0x148E9 &lt;---- АДРЕС ВОЗВРАТА В ПРОЛОГ  
EBP-4 0x12218 &lt;--------XORИТСЯ С COOKIE  
EBP STORED\_EBP &lt;----- ТЕКУЩИЙ EBP - АДРЕС STORED\_EBP  
АДРЕС ВОЗВРАТА В** **ФУНКЦИЮ TRIGGERSTACKOVERFLOWGS**  
  
Одна из проблем здесь заключается в том, что это не нормальная функция, которая при входе и выходе из **ESP** остается такой же, как и до помещения аргументов. Ваши аргументы хорошо сбалансированы. Это функция, которая является прологом функции **TRIGGERSTACKOVERFLOWGS**. Этот код должен быть частью той же функции и не должет быть идти отдельным **CALL**.  
  
Затем программа вычитает значение из регистра **ESP**, чтобы освободить место для переменных для этой функции, и идет, чтобы создать стек, но затем не возвращается, как в обычной функции, ищет адрес возврата и возвращает значение регистра **ESP**, где он был. Это не работает здесь, потому что регистр **ESP** должен сохранить значение, которое он уже отнял, и освободил место для переменных.  
  
В обычной функции регистр **ESP** при возврате равен тому же значения, что и перед передачей аргументов.  
  
![54.png](https://wasm.in/attachments/54-png.5478/)   
  
Но в данном конкретном случае эта специальная функция похожа на часть функции **TRIGGERSTACKOVERFLOWGS**, выполняемой в отдельном **CALL**.  
  
Если принимать регистр **ESP** в качестве нуля в начале функции, я вижу, что при возврате из **CALL** регистр увеличивается на **0x234** байт, потому что внутри функции пролога было сделано несколько инструкций **PUSH**, была выполнена инструкция **SUB** **ESP**, **0x210**, и был осуществлен возврат из функции без восстановления регистра **ESP**.  
  
![55.png](https://wasm.in/attachments/55-png.5479/)   
  
Многие скажут, но если регистр **ESP** не восстановлен, как найти адрес возврата в стеке, который намного ниже значения регистра **ESP**.  
  
Мы говорили, что адрес **EBP-8** указывает на адрес возврата, чтобы вернуться из функции пролога в **TRIGGERSTACKOVERFLOWGS** и **ТЕКУЩИЙ** **ESP** после того, как три **PUSH** из **EBX**, **ESI** и **EDI**остались выше.  
  
![56.png](https://wasm.in/attachments/56-png.5480/)   
  
Если мы посмотрим в функции пролога, увидим, что она возвращает адрес возврата с помощью инструкции **PUSH** - **RET.**  
  
![57.png](https://wasm.in/attachments/57-png.5481/)   
  
Помещенное в стек значение, указанное через адрес **EBP-8**, является адресом возврата. Программа помещает значение обратно в стек и затем выполняет инструкцию **RET**, и программа возвращается к функции **TRIGGERSTACKOVERFLOWGS**, не восстанавливая **ESP** и оставляя весь стек целым, как это было в прологе.  
  
Между инструкцией **PUSH** и **RET** есть только инструкции **MOV** и **LEA**, поэтому стек не затрагивается, и это аналогично **PUSH**-**RET**.  
  
Мы уже знаем, как функция начинается, как все устроено в стеке и как функция возвращается, у нас есть некоторые вещи которые находятся в середине после трех **PUSH** перед возвратом.  
  
Мы создали стек здесь.  
  
![58.png](https://wasm.in/attachments/58-png.5482/)   
  
До этого момента он был создан так.  
  
**ЗНАЧЕНИЕ EBX  
ЗНАЧЕНИЕ ESI  
ЗНАЧЕНИЕ EDI**  
…  
…  
…  
**EBP-10 FS:0  
EBP-C \_\_EXCEPT\_HANDLER4  
EBP-8 0x148E9 &lt;---- АДРЕС ВОЗВРАТА В ФУНКЦИЮ ПРОЛОГ  
EBP-4 0x12218 &lt;--------XORED COOKIE  
EBP STORED\_EBP &lt;----- ТЕКУЩИЙ EBP - АДРЕС STORED\_EBP  
АДРЕС ВОЗВРАТА В ФУНКЦИЮ TRIGGERSTACKOVERFLOWGS**  
  
Мы уже знаем, что ничего из этого не будет потеряно, все, что я добавлю или изменю в прологе в стеке, не будет удалено, поскольку **PUSH-RET** покинет стек, как это было для функции **TRIGGERSTACKOVERFLOWGS**.  
  
Еще одна вещь, которая уже настроена для функции **TRIGGERSTACKOVERFLOWGS**, это регистр **EBP**.  
  
![59.png](https://wasm.in/attachments/59-png.5483/)   
  
С помощью **LEA** вычисляется база для переменных и аргументов не только пролога, но и функции **TRIGGERSTACKOVERFLOWGS**, поскольку начиная с этого момента её значение остается постоянным, даже после возвращения.  
  
Я смотрю функцию **TRIGGERSTACKOVERFLOWGS**, чтобы попытаться увидеть, где это соответствует адресу **EBP-1C**, где программа хранит **COOKIE**.  
  
![60.png](https://wasm.in/attachments/60-png.5484/)   
  
Мы видим, что переменная **MS\_EXC** находится по адрес **EBP-0x18.** Другими словами место, где программа хранит **COOKIE**, которое вы собираетесь проверить, находится чуть выше структуры **MS\_EXC**.  
  
Напомним, что буфер **DST** был инициализирован только с **0x1FF** байтами, и мы сказали, что осталось несколько байтов чуть ниже него, поэтому, если мы поправим размер **DST** на **0x1FF**, у нас будет переменная, в которой сохраняется **COOKIE** в стеке.  
  
![61.png](https://wasm.in/attachments/61-png.5485/)   
  
Здесь я назначаю новый размер и у меня остается четыре пустых байта между ними. Я нажимаю **D,** пока я не изменю на **DWORD** \(**DD**\), и переименую переменную в **COOKIE**.  
  
![62.png](https://wasm.in/attachments/62-png.5486/)   
  
Я вижу, что это по адресу **EBP-1C** \(слева от названия есть позиция относительно **EBP** т.е. **0x0000001C**\).  
  
Затем идет инструкция **PUSH** **EAX** и сохраняется текущее значение регистра **ESP** по адресу **EBP-18**, которое было внутри структуры **MS\_EXC**, которая начинается здесь. Это первое поле той же структуры.  
  
![63.png](https://wasm.in/attachments/63-png.5487/)   
  
Если мы заглянем внутрь структуры, первым полем будет **OLD** **ESP**  
  
![64.png](https://wasm.in/attachments/64-png.5488/)   
  
Так что стек стал таким  
  
**ЗНАЧЕНИЕ EAX  
ЗНАЧЕНИЕ EBX  
ЗНАЧЕНИЕ ESI  
ЗНАЧЕНИЕ EDI**  
…  
**EBP-10 FS:0  
EBP-C \_\_EXCEPT\_HANDLER4  
EBP-8 0x148E9 &lt;---- АДРЕС ВОЗВРАТА В ПРОЛОГ  
EBP-4 0x12218 &lt;--------XORится с COOKIE  
EBP STORED\_EBP &lt;----- ТЕКУЩИЙ EBP - АДРЕС STORED\_EBP  
АДРЕС ВОЗВРАТА В ФУНКЦИЮ TRIGGERSTACKOVERFLOWGS**  
  
Поскольку теперь обе функции совместно используют стек, если мы сравним их, мы увидим, что над **STORED\_EBP** находится значение **MS\_EXC**, поэтому внутри пролога чуть выше переменной "**S**" байты также являются полями указанной структуры.  
  
![65.png](https://wasm.in/attachments/65-png.5489/)   
  
Эти **4** **DWORDS** являются **4** нижними полями структуры **MS\_EXC**.  
  
![66.png](https://wasm.in/attachments/66-png.5490/)   
  
Помните, что последние **4** поля структуры - это другая структура размером **0x10** байтов, т.е. **16** в десятичной системе \(**4** **DWORDS**\), поэтому на изображении отмечены только те **4** **DWORDS**.  
  
![67.png](https://wasm.in/attachments/67-png.5491/)   
  
Двумя важными переменными являются **NEXT** и **EXCEPTION** **HANDLER**. Мы уже знаем их положение в стеке. Мы видим, что переменная **NEXT** в структуре имеет значение **FS:0**, а **EXCEPTIONHANDLER** на данный момент имеет значение **\_\_EXCEPT\_HANDLER4**, хотя они еще не добавлены в цепочку **SEH**.  
  
**ЗНАЧЕНИЕ EAX  
ЗНАЧЕНИЕ EBX  
ЗНАЧЕНИЕ ESI  
ЗНАЧЕНИЕ EDI**  
…  
…  
…  
**EBP-10 FS:0 - \(NEXT\)  
EBP-C \_\_EXCEPT\_HANDLER4 - \(EXCEPTION\_HANDLER\)  
EBP-8 0x148E9 &lt;---- АДРЕС ВОЗВРАТА В ПРОЛОГ -\(SCOPETABLE\)   
EBP-4 0x12218 &lt;--------XORится с COOKIE \(TRYLEVEL\)  
EBP STORED\_EBP &lt;----- ТЕКУЩИЙ EBP - АДРЕС STORED\_EBP  
АДРЕС ВОЗВРАТА В ФУНКЦИЮ TRIGGERSTACKOVERFLOWGS**  
  
Хорошо. У нас создан стек, и мы видим справа синие поля структуры.  
  
Поскольку адрес возврата уже помещен в стек, изменение значения сохраненной переменной не имеет значения.  
  
![68.png](https://wasm.in/attachments/68-png.5492/)   
  
Мы видим, что в по адресу **EBP-8** \(**SCOPETABLE**\) программа сохраняет значение **COOKIE,** **XOR**ит его со значением **0x12218**, которое было в **EBP-4**, а затем в том же **EBP-4**, что является **TRYLEVEL**, сохраняет значение **0xFFFFFFFE**.  
  
В конце программа сохраняет адрес **EBP-10 - NEXT** в регистр **FS:0** с настроенным обработчиком исключений.  
  
Мы знаем, что регистр **FS:0** указывает на последний элемент в списке цепочки исключений, т.е на верхнюю часть всей цепочки.  
  
Помните, что добавление нового элемента в список осуществляется с помощью этого кода  
  
**PUSH OFFSET HANDLER  
PUSH FS:\[0\]  
MOV FS:\[0\], ESP**  
  
Т.е. поскольку здесь выполняется следующая инструкция.  
  
**MOV LARGE FS:0, EAX**  
  
Этот регистр **EAX** является адресом стека, где находится новый **NEXT** и ниже **SEH**.  
  
Так как регистр **EAX** является адресом **EBP-10**, здесь будет переменная **NEXT** и чуть ниже **SEH**, как мы уже говорили.  
  
Если я отлаживаю код и отправляю данные эксплойту, который обходит правильный **IOCTL** для достижения уязвимой функции \(Позже мы увидим, как это сделать. Сейчас же это просто для проверки\).  
  
![69.png](https://wasm.in/attachments/69-png.5493/)   
  
Я вижу, что регистр **FS:0** указывает на верхний элемент цепочки **SEH**. В моем случае он равен **9CCEFCC0**. Если я посмотрю, здесь должны быть переменные **NEXT** и **SEH**. Переменная **NEXT** равна **0xFFFFFFFF**, потому что это последний **NEXT** в цепочке исключений.  
  
![70.png](https://wasm.in/attachments/70-png.5494/)   
  
Функция является типичным универсальным обработчиком. Если я собираюсь увидеть, что это за байты, то нажимаю **C** чтобы создать функцию.  
  
![71.png](https://wasm.in/attachments/71-png.5495/)   
  
Если я продолжу трассировать пролог, я попадаю туда, где регистр **EAX** сохранится в регистр **FS:0.**  
  
![72.png](https://wasm.in/attachments/72-png.5496/)   
  
Здесь мы видим новый драйвер, добавленный в цепочку.  
  
![73.png](https://wasm.in/attachments/73-png.5497/)   
  
Как мы уже рассматривали, адрес **EBP-10** будет новым **NEXT**, а ниже находится **SEH**, который будет являться **\_EXCEPT\_HANDLER4.** Это то значение, которое мы должны будем переписать для эксплуатации  
  
![74.png](https://wasm.in/attachments/74-png.5498/)   
  
Хорошо. У нас уже все хорошо расположено. Пора начинать писать эксплойт.  
  
Метод заключается в том, что, когда мы копируем из пользовательского буфера, который является источником, и мы предоставляем, вместо того, чтобы сломать стек, заполняя его полностью, мы должны вычислить, какой источник копирует **SEH** в стек. Его размер должен быть просто легко быть рассчитан, чтобы закончиться сразу после копирования **SEH**.  
  
Идея состоит в том, что, поскольку сбой происходит при доступе на чтение к буферу пользовательского режима, это приводит к тому, что он обрабатывается как сбой в режиме пользователя и происходит переходит к **SEH**, а не обрабатывается как сбой ядра, что вызывает **BSOD**.  
  
Метод работает, но эксплойт делаем сбой и вызывает **BSOD.** Так что нам нужно будет увидеть, где произошел сбой. Наверняка есть что-то что мы не видим.  
  
Основное объяснение этого метода находится здесь:  
  
[http://poppopret.blogspot.com/2011/07/windows-kernel-exploitation-basics-part\_16.html](http://poppopret.blogspot.com/2011/07/windows-kernel-exploitation-basics-part_16.html)  
  
И исходный код публичного эксплойта находится здесь:  
  
[https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/tree/master/Exploit](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/tree/master/Exploit)  
  
Я не собираюсь делать все это также на **PYTHON**, потому что это того не стоит, но давайте посмотрим, как автор это объясняет и исправим, то что не работает.  
  
Прежде всего, если бы мы сделали это в **PYTHON**, у нас была бы проблема, которую можно решить, но, компилируя его в **C++**, у нас уже есть модуль, который помимо запуска и экслуатации повышения привилегий, мы можем скомпилировать его по своему вкусу, например, без **SAFESEH**, или **DEP** или **ASLR.** В опциях **VISUAL STUDIO** позволят нам выбрать то что нужно, поэтому, если кто-то загружает решение, т.е. файл **SLN** в **VISUAL STUDIO**, вам придется изменить параметры по умолчанию.  
  
![75.png](https://wasm.in/attachments/75-png.5499/)   
  
Чуть выше находится это.  
  
![76.png](https://wasm.in/attachments/76-png.5500/)   
  
Хорошо. Я приложу скомпилированный файл с его символами **HACKSYSEVDEXPLOIT.EXE** и **HACKSYSEVDEXPLOIT.PDB**, чтобы его было легко увидеть в **IDA**.  
  
Исполняемый файл скомпилирован для всех уязвимостей, которые есть у драйвера, и его выполнение в консоли в **WINDOWS** **7** **32** с аргументами **-G -C** **XXX.EXE** достаточно, так как я уже добавляю в конце этого метода выполнение калькулятора c правами **SYSTEM** после поднятия прав. В остальных вместо **XXX.EXE** придется подставить **CALC.EXE** или **CMD.EXE**  
  
Хорошо. Мы переходим к функции, которая использует эту уязвимость. В данном случае - **STACKOVERFLOWGSTHREAD**.  
  
![77.png](https://wasm.in/attachments/77-png.5501/)   
  
После исправления некоторых проблем консоли, которые не имеют отношения, давайте проанализируем эксплойт, который мы открываем в **IDA**, и видим, что эксплойт начинается здесь:  
  
![78.png](https://wasm.in/attachments/78-png.5502/)   
  
Внутри мы видим вызов функции **CREATEFILE** для получения дескриптора драйвера.  
  
![79.png](https://wasm.in/attachments/79-png.5503/)   
  
Все это так же, как и случаи, которые мы видели в предыдущих ядрах.  
  
Регистр **EBX** остается с дескриптором драйвера, он используется только при вызове **DEVICEIOCONTROL** ниже.  
  
![80.png](https://wasm.in/attachments/80-png.5504/)   
  
Хорошо. Затем идет вызов функции **CREATEFILEMAPPING**, что является пространством виртуальной памяти, которое будет связано с содержимым файла. \(Функция не резервирует память, только создает объект и возвращает дескриптор\)  
  
[https://docs.microsoft.com/en-us/windows/desktop/memory/file-mapping](https://docs.microsoft.com/en-us/windows/desktop/memory/file-mapping)  
  
![81.png](https://wasm.in/attachments/81-png.5505/)   
  
Но если мы посмотрим в описание функции **CREATEFILEMAPPING**, мы увидим, что первым аргументом является дескриптором файла, но нам также говорится, что может быть передан аргумент **INVALID\_HANDLE\_VALUE**. В этом случае, программа создаст отображение файла, не связывая его с файлом, и это будет общая анонимная память.  
  
![82.png](https://wasm.in/attachments/82-png.5506/)   
  
![83.png](https://wasm.in/attachments/83-png.5507/)   
  
Хорошо. Это тот случай, поэтому мы видим, что когда вызывается эта **API**, вы передаете значение **0xFFFFFFFF**, которое является **INVALID\_HANDLE\_VALUE.**  
  
![84.png](https://wasm.in/attachments/84-png.5508/)   
  
В исходном коде, под названием **SHARED** **MEMORY**, созданном здесь, мы видим, что функции передаются разрешение на выполнение, чтение и запись.  
  
![85.png](https://wasm.in/attachments/85-png.5509/)   
  
Хорошо. Она возвращает нам дескриптор файлового отображения.  
  
![86.png](https://wasm.in/attachments/86-png.5510/)   
  
Затем программа вызывает функцию **MAPVIEWOFFILE**, которая отображает объект в памяти, зарезервировав необходимое для него пространство.  
  
![87.png](https://wasm.in/attachments/87-png.5511/)   
  
![88.png](https://wasm.in/attachments/88-png.5512/)   
  
Хорошо. Функция возвращает адрес начала секции, созданного для отображения файлов.  
  
Чтобы отладить эксплойт в режиме пользователе, несмотря на драйвер, я копирую сервер **IDA** - **WIN32\_REMOTE.EXE** в целевую машину и запускаю его.  
  
![89.png](https://wasm.in/attachments/89-png.5513/)   
  
Я запускаю его на сервере с правами администратора в целевой системе, а на машине, где я реверсил эксплойт, меняю отладчик на удаленный отладчик **WINDOWS.** В **PROCESS** **OPTIONS** я указываю **IP**-адрес и порт.  
  
![90.png](https://wasm.in/attachments/90-png.5514/)   
  
![91.png](https://wasm.in/attachments/91-png.5515/)   
  
Напомним, что мы можем отлично отладить этот эксплойт в пользовательском режиме, но на шелл-код, который вызывается из ядра, мы не сможем поставить **BP** или что-либо еще, потому что это вызовет исключение **INT3** в ядре, которое не обрабатывается как в пользовательском режиме, и будет создан **BSOD**.  
  
Если мы запустим файл без аргументов, он покажет нам опции.  
  
![92.png](https://wasm.in/attachments/92-png.5516/)   
  
Я запускаю эксплойт с аргументами **-G**, чтобы задействовать уязвимость **STACK** **OVERFLOW** **GS**,  
  
![93.png](https://wasm.in/attachments/93-png.5517/)   
  
Теперь я ожидаю.  
  
![94.png](https://wasm.in/attachments/94-png.5518/)   
  
Так что я могу теперь прикрепить **IDA**, ту где я реверсил эксплойт \(не ту, которой был проанализирован драйвер\)  
  
![95.png](https://wasm.in/attachments/95-png.5519/)   
  
Нажав клавишу в целевой машине, чтобы пропустить паузу, мы останавливаемся на **BP**, который я ставлю после паузы.  
  
![96.png](https://wasm.in/attachments/96-png.5520/)   
  
Я дохожу до функции **CREATEFILEMAPPING**.  
  
![97.png](https://wasm.in/attachments/97-png.5521/)   
  
Пройдя вызов с помощью **F8**, мне возвращается дескриптор файла.  
  
![98.png](https://wasm.in/attachments/98-png.5522/)   
  
Как мы уже говорили, этот дескриптор передается в регистре **ESI.**  
  
![99.png](https://wasm.in/attachments/99-png.5523/)   
  
Здесь нам вернется адрес отображаемого файла**.**  
  
![100.png](https://wasm.in/attachments/100-png.5524/)   
  
Это секция будет из **0x1000** байт.

 Проблема в том, что эта секция будет использоваться источником, и вам нужно скопировать данные до **SEH**, а затем завершить ввод, поэтому происходит сбой чтения перед копированием всего стека и сбой в стеке ядра.  
  
Я поставлю эту **IDA** на паузу на одну минуту и открою другую, где у меня есть драйвер.  
  
Одна вещь, которую я не видел и допустил ошибку - это то, что буфер назначения  
  
![2.png](https://wasm.in/attachments/2-png.5526/)   
  
Мы видим, что он инициализируется байтами **0x1FF**, но непосредственно перед обнулением байта, который находится чуть выше, и место назначения начинается с **VAR\_21C**, поэтому вам нужно исправить буфер назначения, чтобы иметь возможность хорошо вычислять размер, и теперь начинать с **VAR\_0x21C**, и он будет равен **0x200** байт.  
  
![3.png](https://wasm.in/attachments/3-png.5527/)   
  
Теперь, если всё в порядке, я переименую его в **BUFFER\_DESTINO**.  
  
Это выглядит хорошо. Здесь прямо в функции **MEMCPY**, и мы можем скопировать количество байтов, которые нам нужны.  
  
![4.png](https://wasm.in/attachments/4-png.5528/)   
  
Очевидно, что мы не должны копировать с начала секции файлового отображения, потому что данные должны быть копированы только до **SEH**. Я должен увидеть, сколько байтов я должен скопировать.  
  
Мы должны скопировать **0x200** байт, чтобы заполнить буфер. Еще **4**, чтобы перезаписать **COOKIE**, а затем ещё идёт структура **MS\_EXC**.  
  
Внутри структуры есть **8** байтов, а затем **NEXT** и **SEH**, поэтому было бы так.  
  
Всего cкопировано = **0x200** + **4** + **8** + **NEXT** + **SEH**.  
  
![5.png](https://wasm.in/attachments/5-png.5529/)   
  
Т.е. **0x214** байтами мы перезаписываем **SEH**.  
  
![6.png](https://wasm.in/attachments/6-png.5530/)   
  
Поскольку длина секции составляет **0x1000** байт, чтобы узнать, какое адрес передать, чтобы начать копирование, в начальный адрес секции я добавляю **0x1000**, а затем вычитаю **0x214**. При этом программа будет использовать этот новый адрес в качестве входного буфера, просто, чтобы перезаписать **SEH** и вызвать сбой при чтении.  
  
Давайте посмотрим на это в отладчике, который был остановлен на эксплойте.  
  
![7.png](https://wasm.in/attachments/7-png.5531/)   
  
Мы видим, что адрес файлового отображения, хранится в регистре **ESI и к нему** добавляется значение **0xDEC.** Т.е. **0x1000** – **0x214 = 0xDEC**.  
  
![8.png](https://wasm.in/attachments/8-png.5532/)   
  
![9.png](https://wasm.in/attachments/9-png.5533/)   
  
На моей машине **0x2C0DEC** будет адресом, с которого начнется копирование **0x214** байт. Источник функции **MEMCPY** в стек.  
  
Затем остается скопировать необходимый буфер, что и делается дальше.  
  
С помощью функции **MEMSET** заполняется вcя секция буквами **A** \(**0x41**\)  
  
![10.png](https://wasm.in/attachments/10-png.5534/)   
  
Здесь заполняется входной буфер.  
  
![11.png](https://wasm.in/attachments/11-png.5535/)   
  
Мы видим, что в позицию **0x0204** записывается значение **0x42424242**. Это предположительно говорит о том, что программа перезаписала **COOKIE**, так как буфер занимает **0x200**, а **COOKIE**находится ниже. Для меня, так как это значение **0x204**, перезаписывается **DWORD** чуть ниже **COOKIE** - первое поле структуры **MS\_EXC**.  
  
Затем программа записывает по адресу **ESI** + **4** значение **0x43434343**.  
  
![12.png](https://wasm.in/attachments/12-png.5536/)   
  
Затем добавляет значение **8** к исходному регистру **ESI** и записывает **NEXT** и **SEH**.  
  
![13.png](https://wasm.in/attachments/13-png.5537/)   
  
Мы видим, что, как я уже сказал, **COOKIE** не перезаписался значением **0x41414141**, и я затер чуть ниже **4** **DWORD** структуры **MS\_EXC**.  
  
![14.png](https://wasm.in/attachments/14-png.5538/)   
  
Это **4** **DWORD** которые я перезаписал, поэтому последний **DWORD -** это **SEH**.  
  
![15.png](https://wasm.in/attachments/15-png.5539/)   
  
Чуть ниже **SEH** заканчивается секция. Поскольку мы хотим вызвать сбой при чтении мы продолжим чтение данных. Мы передадим размер немного больше, чем **0x214**.  
  
Я устанавливаю **BP** перед функцией **DEVICEIOCONTROL**, и когда я нажимаю **RUN**, мне нужно нажать клавишу в целевой маишине, чтобы пройти следующую системную паузу.  
  
![16.png](https://wasm.in/attachments/16-png.5540/)   
  
Давайте посмотрим аргументы, которые передаются функции.  
  
![17.png](https://wasm.in/attachments/17-png.5541/)   
  
Указатель на возвращенные байты передаются с помощью инструкции **LEA**. Затем идет **PUSH** **0** и **PUSH 0** для выходного буфера. Его размер не имеет значения. Затем мы видим, что количество байтов, которые мы передает функции, чтобы она скопировала из входного буфера, равно **0x218** или на **4** байт больше, чем длина входного буфера, который был равен **0x214**. Это приведет к сбою при чтении в конце источника.  
  
Адрес входного буфера был оставлен в регистре **EDI.**  
  
![18.png](https://wasm.in/attachments/18-png.5542/)   
  
И затем передается код **IOCTL** **0x222007** от этой ошибки **STACK** **OVERFLOW** **GS** и дескриптор устройства, который находится в регистре **EBX.**  
  
Мы уже проанализировали эксплойт. Поэтому теперь мы можем закрыть его и присоединить **IDA** с анализом драйвера к **ЯДРУ** и посмотреть, как копируются данные.  
  
Прежде чем прикрепить **IDA**, я поставлю **BP** в начале уязвимой функции.  
  
![19.png](https://wasm.in/attachments/19-png.5543/)   
  
![20.png](https://wasm.in/attachments/20-png.5544/)   
  
Готово. **IDA** уже обнаружила, что это тот же файл, который я проанализировал, и если я соглашусь и перемещу базу секции, **IDA** скажет, что это тот же файл.  
  
Я запускаю эксплойт на целевой машине.  
  
![21.png](https://wasm.in/attachments/21-png.5545/)   
  
![22.png](https://wasm.in/attachments/22-png.5546/)   
  
Мы останавливаемся на **BP**.  
  
![23.png](https://wasm.in/attachments/23-png.5547/)   
  
Как мы уже говорили, будут скопированы **NEXT** и **SEH**, которые мы должны будем перезаписать позже в функции **MEMCPY**.  
  
![24.png](https://wasm.in/attachments/24-png.5548/)   
  
Потому что, когда мы нажимаем **RUN**, мы будем копировать данные и продолжим, не имея возможности остановить этот процесс. Мы можем установить **BPM** **ON** **WRITE**, чтобы остановить отладчик, когда скопируется **NEXT** прямо перед сбоем. Поэтому мы посмотрим, все ли в порядке.  
  
![25.png](https://wasm.in/attachments/25-png.5549/)   
  
Я вставил это в панель **WINDBG**.  
  
![26.png](https://wasm.in/attachments/26-png.5550/)   
  
Я создаю сегмент и преобразовываю его в код.  
  
![27.png](https://wasm.in/attachments/27-png.5551/)   
  
Или если мне хочется посмотреть на сегмент в панели **WINDBG**, я делаю так.  
  
![28.png](https://wasm.in/attachments/28-png.5552/)   
  
Напомним, что когда я armada источник мы помещаем значение **0x44444444,** чтобы перезаписать значение **NEXT**.  
  
![29.png](https://wasm.in/attachments/29-png.5553/)   
  
Это изображение выше было источником. Давайте посмотрим, хорошо ли оно перезаписано в стеке.  
  
![30.png](https://wasm.in/attachments/30-png.5554/)   
  
Вот оно. Я останавливаюсь на **BPM ON WRITE** сразу после копирования **NEXT**, и теперь я скопирую **SEH**. Я нажимаю **F7**.  
  
![31.png](https://wasm.in/attachments/31-png.5555/)   
  
Сюда я скопирую наш **SEH**.  
  
Также я могу посмотреть на него в **IDA**.  
  
![32.png](https://wasm.in/attachments/32-png.5556/)   
  
Конечно, модуль эксплойта, куда будет переходить отладчик, скомпилирован без **DEP** и без **SAFE** **SEH**, поскольку это является частью эксплуатации. Если бы он был создан с **PYTHON**, проблем не было бы. Вам нужно было бы создать область памяти, которая позволила бы ему работать с функцией **VIRTUALALLOC**, скопировать туда код и указать адрес этой области как **SEH**.  
  
Давайте не будем забывать, что это **PRIVILEGE** **ESCALATION**, поэтому у нас уже есть выполнение кода на машине, но с обычным пользователем. Идея состоит в том, чтобы масштабироваться до прав **SYSTEM**, чтобы мы могли выполнять действия на компьютере, ограниченные нашими привилегиями, но запускать **EXE** с теми же привилегией. Также, если бы это был **PYTHON**, мы должны установить **PYTHON** для запуска .**PY**.  
  
Давайте посмотрим на процедуру обработчика исключений.  
  
![33.png](https://wasm.in/attachments/33-png.5557/)   
  
Я уже создал сегмент, я преобразовал его в код с **C**, и я создал функцию.  
  
![34.png](https://wasm.in/attachments/34-png.5558/)   
  
Здесь я не могу поставить **BP** в отладчике в пользовательском режиме на целевой машине, но могу сделать так.  
  
![35.png](https://wasm.in/attachments/35-png.5586/)   
  
Я помещаю эту команду в **WINDBG**. Затем я нажимаю **RUN**.  
  
Отладчик остановился здесь. Наш обработчик исключений работает.  
  
![36.png](https://wasm.in/attachments/36-png.5587/)   
  
Конечно, этот код - это шелл-код который называется как **TOKEN** **STEALER**, который уже был проанализирован в предыдущих туториалах.  
  
Ошибка в исходном коде была в отмеченной области после возврата, чтобы украсть системный токен и сохранить его, чтобы повысить привилегии нашему процессу. Есть инструкция **POPAD**, которая восстанавливает регистры, сохраненные в начале с помощью инструкции **PUSHAD**, И потом не так легко вернуться из ядра исключения к режиму пользователю без прерывания, поэтому мы следовали советам, используя инструкцию **SYSEXIT**.  
  
![37.png](https://wasm.in/attachments/37-png.5588/)   
  
В регистр **EDX** вы должны поместить регистр **EIP**, куда программа вернетесь, когда вернетесь в пользовательский режим, а в регистр **ECX** - регистр **ESP**. В моем случае, поскольку файл компилирован без **ASLR**, я помещаю в регистр **EDX** адрес чуть ниже вызова **DEVICEIOCONTROL**, а в регистр **ESP** адрес основания стека **0x12FF00**, который не совпадает со значением, которое выполнялось до вызова функции **DEVICEIOCONTROL**, но, поскольку я сохранил адрес в секции данных в регистре **ESP**, которое у меня был, когда я вернусь, я смогу восстановить правильный регистр **ESP**.  
  
В другой **IDA** с анализом модуля эксплойта я вижу адрес, куда я вернусь.  
  
![38.png](https://wasm.in/attachments/38-png.5589/)   
  
В текущей **IDA**, в которой я отлаживаю, я вижу ту же часть кода.  
  
![39.png](https://wasm.in/attachments/39-png.5590/)   
  
Я могу поставить здесь **BP**.  
  
![40.png](https://wasm.in/attachments/40-png.5591/)   
  
Я удаляю предыдущие **BP**.  
  
![41.png](https://wasm.in/attachments/41-png.5592/)   
  
И нажимаю **RUN**.  
  
![42.png](https://wasm.in/attachments/42-png.5593/)  
  
Я вижу, что программа вернулась в режим пользователя с регистрами **EIP** и **ESP**, которые я установил до вызова **SYSEXIT**.  
  
Здесь восстанавливается регистр **ESP.** Идет чтение с того места, где вы его сохранили, в секции данных **0x4212B0**.  
  
![43.png](https://wasm.in/attachments/43-png.5594/)  
  
Теперь я буду выполнять калькулятор или код, который я хочу, с привилегиями **SYSTEM**. Я мог бы, например, инжектировать код в какой-нибудь процесс **SYSTEM**, и выйти.  
  
![44.png](https://wasm.in/attachments/44-png.5595/)   
  
Я удаляю все **BP** и нажимаю **RUN**.  
  
![45.png](https://wasm.in/attachments/45-png.5596/)   
  
![46.png](https://wasm.in/attachments/46-png.5597/)   
  
Давайте посмотрим, какой пользователь является владельцем.  
  
![47.png](https://wasm.in/attachments/47-png.5598/)   
  
Готово. Я закончил. Я могу повышать привилегии до **SYSTEM**.  
  
Я приложил **ZIP** файл с измененным исходным кодом и скомпилированным исполняемым файлом. Помните, что если вы скомпилируете его самостоятельно, вы должны сделать это без **DEP**, без **SAFESEH** и без **ASLR**, и он будет работать только в **32**-разрядной версии **WINDOWS** 7 и отрегулировать.

