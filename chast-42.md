# Часть 42

 В 41 части**,** для практики было оставлено два упражнения. К сожалению, никто не прислал мне решения. Это заставляет меня задаться вопросом, стоит ли оно того, что я делаю. По крайней мере для меня это сейчас вопрос. Ни обратной связи, ни вопросов ко мне. Ничего нет.  
  
Это заставляет меня переосмыслить вещи и спросить себя, стоит ли мне заходить с этим курсом так далеко, как я думал с самого начала. Мы увидим, какое решение мы примем в отсутствии обратная связь. Сейчас же, мы будем решать упражнение из главы **41**.  
  
Нам необходимо обновить до новой версии плагин **KEYPATCH,** поскольку мы будем использовать его в конце.  
  
![1.png](https://wasm.in/attachments/1-png.3095/)   
[https://github.com/keystone-engine/keypatch](https://github.com/keystone-engine/keypatch)  
  
Я заменяю файл .**PY** новым скриптом.  
  
[http://ricardo.crver.net/WEB/INTRODUCCION AL REVERSING CON IDA PRO DESDE CERO/EJERCICIOS/](http://ricardo.crver.net/WEB/INTRODUCCION%20AL%20REVERSING%20CON%20IDA%20PRO%20DESDE%20CERO/EJERCICIOS/)  
  
Давайте откроем пример **41** в **IDA**.  
  
Я буду стараться не использовать символы, так как у вас их то же нет. Поэтому мы будем это делать похожим способом.  
  
![2.png](https://wasm.in/attachments/2-png.3096/)   
  
Если мы посмотрим **STRINGS** **WINDOWS**, мы увидим строку **MYPEPE**.**DLL**. Поэтому, возможно, что необходимо поместить библиотеку в ту же папку. Это та же самая **DLL** из предыдущих упражнений.  
  
![3.png](https://wasm.in/attachments/3-png.3097/)   
  
Я помещаю библиотеку в нужную папку.  
  
![4.png](https://wasm.in/attachments/4-png.3098/)   
  
Я делаю двойной щелчок по этой строке.  
  
![5.png](https://wasm.in/attachments/5-png.3099/)   
  
Мы видим ссылку. Мы идем в неё с помощью нажатия **X** или **CTRL** + **X.**  
  
![6.png](https://wasm.in/attachments/6-png.3100/)   
  
Мы видим, что программа загружает библиотеку здесь. Поэтому всё хорошо. Это похоже на функцию **MAIN**. Поскольку это консольная программа, если это так, то она должна иметь функцию в качестве ссылки, которой передаётся такие аргументы как **ARGC**, **ARGV** и т.д.  
  
![7.png](https://wasm.in/attachments/7-png.3101/)   
  
Мы видим, что в ссылке на функцию, если мы пойдем туда, то это обычный вызов в функцию **MAIN**. Вы можете увидеть аргументы консоли.  
  
![8.png](https://wasm.in/attachments/8-png.3102/)   
  
Поэтому, по адресу **401090** находится функция **MAIN**. Мы переименовываем её.  
  
![9.png](https://wasm.in/attachments/9-png.3103/)   
  
Здесь нет буфера в стеке для защиты. Вот почему программа не добавляет переменную **CANARY** несмотря на то, что программа скомпилирована с этой опцией.  
  
Давайте начнем реверсить.  
  
![10.png](https://wasm.in/attachments/10-png.3104/)   
  
Здесь, мы видим, что программа читает запись **IAT** **SYSTEM**, которая находится в секции **IDATA**. Адрес указанной **API** помещается в регистр **EAX**.  
  
Иногда, если вы испытываете некоторые сомнения в синтаксисе **IDA**, используйте **KEYPATCH**, чтобы увидеть простую альтернативу пока не привыкните к ней.  
  
![11.png](https://wasm.in/attachments/11-png.3105/)   
  
Здесь, Вы можете увидеть запись **IAT. IDA** логически говорит нам о типе **EXTRN**, потому что это внешняя **API** импортированного модуля.  
  
![12.png](https://wasm.in/attachments/12-png.3106/)   
  
Конечно, в **IMPORTS** есть импортированные функции для модуля и адрес записи **IAT,** который показывает значение **4020A8**, поэтому у нас всё совпадает.  
  
![13.png](https://wasm.in/attachments/13-png.3107/)   
  
Затем программа запишет в глобальную переменную **DWORD**\_**403088,** \(которая является **DWORD\)** значение регистра **EAX**.  
  
![14.png](https://wasm.in/attachments/14-png.3108/)   
  
Мы помним, что в **IDA** если существует префикс типа данных перед адресом, это означает, что содержимое этого адреса имеет тот же тип. В этом случае это **DWORD**. По крайней мере это **4** байта. Также программа записывает адрес **API** здесь.  
  
Поэтому мы переименовываем глобальную переменную в **P**\_**SYSTEM**.  
  
Мы знаем, что это переменная длиной **4** байта и так как она сохраняет адрес, то она должна быть типа указатель. Я изменяю её тип.  
  
![15.png](https://wasm.in/attachments/15-png.3109/)   
  
Поскольку я знаю, что это указатель на **API**, то могу легко сделать его указателем на что-то неизвестное.  
  
**VOID \* P\_SYSTEM**  
  
В любом случае, нет необходимости иметь слишком точные определения, потому что они лишние. Важно просто то, что это указатель на что-то.  
  
![16.png](https://wasm.in/attachments/16-png.3110/)   
  
Поэтому, в конечном итоге, это будет переменная типа указатель, которая сохраняет системный **API** адрес.  
  
![17.png](https://wasm.in/attachments/17-png.3111/)   
  
Существует другая переменная того же типа, которая хранит адрес **API** **SETPROCESSDEPPOLICY**. Я делаю то же самое.  
  
Я изменяю тип также в декомпиляторе **HEXRAYS** с помощью **F5**. Изменение типа ни на что не влияет.  
  
![18.png](https://wasm.in/attachments/18-png.3112/)   
  
![19.png](https://wasm.in/attachments/19-png.3113/)   
  
Это не имеет большого значение. Это просто нужно, чтобы показать Вам больше вариантов.  
  
![20.png](https://wasm.in/attachments/20-png.3114/)   
  
Мы видим, что глобальная переменная **P\_SYSTEM** используется повторно и сохраняет указатель \(используется инструкция **LEA** для поиска адреса\) на переменную **SIZE**, которая является **DWORD**. Очевидно, it will cast it to do it **C++**\(**??? Опять куча itов. Не понял как тут правильно будет**\), но здесь это не имеет значения. Они обе являются указателями.  
  
Обычно, когда переменная используется повторно, я помещаю горизонтальные полосочки, так как я не могу поставить диагональные и затем помещаю второе имя.  
  
Что-то вроде этого:  
  
**P\_SYSTEM\_\_\_\_\_P\_SIZE**  
  
В сложных функциях они много раз повторяется и мы должны следовать этому.  
  
![21.png](https://wasm.in/attachments/21-png.3115/)   
  
Затем программа сравнивает переменную **ARGC**, которая представляет собой число аргументов с числом **2**. Таким образом это имя исполняемого файла + аргумент, т.е. всего два аргумента. Если нет двух аргументов, программа пропускает всё и выходит из функции напрямую.  
  
![22.png](https://wasm.in/attachments/22-png.3116/)   
  
Мы видим, что **ARGV** это массив и что в позиции **0** он хранит строку имени исполняемого файла и если мы добавим в нему **4,** то программа получит адрес строки первого аргумента.  
  
![23.png](https://wasm.in/attachments/23-png.3117/)   
  
Затем программа передает эту строку в функцию **ATOI**, чтобы попытаться преобразовать строку в целое число. Если у функции это не получается, программа выдаёт ошибку.  
  
![24.png](https://wasm.in/attachments/24-png.3118/)   
  
![25.png](https://wasm.in/attachments/25-png.3119/)   
  
После возврата из функции **ATOI** это значение сохраняется в переменную **SIZE**, которая находится в стеке.  
  
![26.png](https://wasm.in/attachments/26-png.3120/)   
  
Не путайте её с глобальной переменной **P\_SYSTEM\_\_\_\_\_P\_SIZE**, которая имеет сохраненный **АДРЕС** этой же переменной **SIZE**.  
  
Программа сравнивает это значение размера, которое пришло из **ARGV** со значением **0x300** и если оно больше, программа переходит и возвращается в функцию **MAIN.** Конечно, этот **SIZE** является знаковым, потому что сравнение с использованием инструкции **JLE** говорит нам об этом.  
  
![27.png](https://wasm.in/attachments/27-png.3121/)   
  
Поскольку переменная является знаковой, когда мы передаем ей отрицательное значение, она будет меньше **0x300**. Например, если я передам ей значение **-1**, это значение будет меньше **0x300**, потому что рассматривается знак и переменная пройдет сравнение.  
  
Очевидно, если эта переменная **SIZE** используется как размер в **API** функции, которая принимает переменную как беззнаковую, то в программе может случиться переполнение, потому что для этой **API** функции значение не будет отрицательным, но без знака. Например, если значение равно **-1**, для **API**, которая принимает это значение как положительное, максимальным положительным будет значение **0xFFFFFFFF**. Т.е. **-1** равно **0xFFFFFFFF**.  
  
![28.png](https://wasm.in/attachments/28-png.3122/)   
  
Мы видим функцию, ей аргументом является переменная **SIZE**. Мы ещё не переименовывали её. Давайте посмотрим что она делать. Пойдем туда и посмотрим.  
  
![29.png](https://wasm.in/attachments/29-png.3123/)   
  
Мы видим, что есть здесь есть функция **GETS\_S** для ввода данных. Поэтому я даю функции имя **INGRESO**.  
  
Эта функция **GETS\_S** имеет переменную **SIZE**, которая принимается как беззнаковая и может вызвать переполнение буфера.  
  
![30.png](https://wasm.in/attachments/30-png.3124/)   
  
Здесь мы видим, что тип переменной **SIZEINCHARACTERS** является типом **SIZE\_T**.  
  
![32.png](https://wasm.in/attachments/32-png.3126/)   
  
И этот **SIZE\_T** является беззнаковым. Поэтому я уверен, что мы можем переполнить буфер. Давайте посмотрим насколько он большой. Хотя мы уже видели, что я сделал его плохим, но программы пытается фильтровать **SIZE** больше чем **0x300** байт. Поэтому очень вероятно, что размер буфера таков.  
  
![33.png](https://wasm.in/attachments/33-png.3127/)   
  
Мы видим, что буфер находится в секции **DATA** и **IDA** говорит мне, что его размер равен **0x64** байт. Чуть ниже буфера мы видим глобальные переменные **P**\_**SETDEP** и **P\_SYSTEM**\_\_\_\_**P**\_**SIZE**. Поэтому здесь нет ошибки. Максимальная проверка позволяет нам переполнить даже этот **0x64** байтный буфер \(**100** десятичных байт\), без требования быть отрицательным. Только с размером больше чем **0x64** байта.  
  
![34.png](https://wasm.in/attachments/34-png.3128/)   
  
Как только я запишу больше чем **0x64** байта, я буду продолжать двигаться вниз и смогу перезаписать сохраненные указатели в секции **DATA**.  
  
Сейчас, после того как Вы перезапишите указатели, будет ли программа использовать эти указатели?  
  
![35.png](https://wasm.in/attachments/35-png.3129/)   
  
Я вижу в ссылках на **P**\_**SETDEP**, что есть вызов с использованием этого указателя на функцию и что, если я перезаписываю его с помощью переполнения, он может отклонить выполнение программы.  
  
![36.png](https://wasm.in/attachments/36-png.3130/)   
  
Это происходит сразу после функции **GETS**\_**S**. Это прекрасно. Давайте сделаем скрипт.  
  
![37.png](https://wasm.in/attachments/37-png.3131/)   
  
Я изменяю скрипт, который был достаточно похожий и устанавливаю размер равным **-1**. Он будет проходить проверку. Я помещаю **0x64** байта символов **A** чтобы заполнить буфер, и затем я помещаю значение **0x99989796**, которое предположительно должно перезаписать указатель, который находится чуть ниже.  
  
Поскольку **ROP** для библиотеки **MYPEPE**.**DLL** уже создан, я оставляю его. Я увижу, как я расположу **ROP**. Сейчас я запускаю скрипт и присоединяю **IDA** к процессу, помещаю **BP** сразу после функции **GETS**\_**S**, для того, чтобы остановится там.  
  
![38.png](https://wasm.in/attachments/38-png.3132/)   
  
![39.png](https://wasm.in/attachments/39-png.3133/)   
  
![40.png](https://wasm.in/attachments/40-png.3134/)   
  
Мы видим, что буфер выглядит почти полным. Давайте пойдем туда, чтобы увидеть его.  
  
Если я нажму **U** для **UNDEFINE,** мы увидим много символов **A**. Давайте посмотрим перезаписался ли указатель.  
  
![41.png](https://wasm.in/attachments/41-png.3135/)   
  
Мы должны увидеть, перезаписали ли мы указатель.  
  
![42.png](https://wasm.in/attachments/42-png.3136/)   
  
Я нажимаю **D** до тех пор пока не получу **DWORD** и вижу что это всё хорошо перезаписалось. Установлено значение, которое я хотел.  
  
![43.png](https://wasm.in/attachments/43-png.3137/)   
  
Я вижу, что у процесса нет **DEP**, потому что мы перезаписали правильный **API** **SETPROCESSDEPPOLICY**, которая собиралась включить его. Поэтому здесь нам не понадобится **ROP**.  
  
![44.png](https://wasm.in/attachments/44-png.3138/)   
  
Регистр **EAX** указывает на буфер, который заполнен **A**. Поэтому если я смогу перейти туда и разместить шеллкод в начале буфера и выполнить его.  
  
Я мог бы искать вызов **CALL** **EAX** в библиотеке **MYPEPE**, который не содержит защиту **ASLR**. Я использую новый **KEYPATCH** с опцией **SEARCH** и ввожу инструкцию **CALL** **EAX**.  
  
![45.png](https://wasm.in/attachments/45-png.3139/)   
  
![46.png](https://wasm.in/attachments/46-png.3140/)   
  
Мы видим в результатах, что есть несколько, которые принадлежат библиотеке **MYPEPE**. Я выбираю некоторые для примера.  
  
![47.png](https://wasm.in/attachments/47-png.3141/)   
  
Когда я иду туда, я нажимаю **C** для преобразования его в код, потому что я его не дизассемблировал.  
  
По адресу **0x7802C16E** будет инструкция **CALL** **EAX**, которую я выбрал. Я добавляю этот адрес в скрипт.  
  
![48.png](https://wasm.in/attachments/48-png.3142/)   
  
Я помещаю шеллкод вперед, потому что он переходит в начало буфера и не меняет длину перед указателем. Оставшаяся часть шеллкода вычитается из общего количества букв **A**. Мне больше не понадобится **ROP**. Поэтому я удаляю его.  
  
![49.png](https://wasm.in/attachments/49-png.3143/)   
  
Наша курочка готова. Шеллкод запускает калькулятор. Я надеюсь, что кто-то сделает меня счастливым, решив задачку **41B** или, по крайней мере, просто попробует её на вкус.  
  
============================================================  
\#8eqw0uExIPQMo0hlG2SMbg.kWxA60qd204.wQ0f6qnVEDF3sTM4kUnjA82Jgnlue8Wsgi0LIXEGPRLM89DcLVaUVNH29WUFmLizrcwP9OtNDlc4wPiQ6DtpTgbIFIhKqOATEW8MBxHDk2Uvz/8H8BgX5L2XHkS/zfDWlnPEVsMXsg  
**=======================================================  
  
Автор текста: Рикардо Нарваха** - **Ricardo** **Narvaja** \(**@ricnar456**\)  
Перевод на английский: **IvinsonCLS \(@IvinsonCLS\)**  
Перевод на русский с испанского+английского: **Яша\_Добрый\_Хакер\(Ростовский фанат Нарвахи\).**  
Перевод специально для форума системного и низкоуровневого программирования — **WASM.IN  
22.04.2018  
Версия 1.0**

