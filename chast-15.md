# Часть 15

 В предыдущей части, мы увидели несколько из многих методов, которые существуют для обнаружения и получения **OEP** в упакованном файле. Сейчас, вернёмся к двум пропущенными шагам: это **ДАМП** и **ВОССТАНОВЛЕНИЕ** **IAT**, стараясь объяснить их в этом туториале.  
  
![1.png](https://wasm.in/attachments/1-png.1538/)   
  
Мы снова попадаем в **OEP** программы и делаем её **ПОВТОРНЫЙ АНАЛИЗ**. Теперь у нас уже есть всё, чтобы сделать **ДАМП**.  
  
Сейчас будем использовать **IDC** скрипт, а не **PYTHON**.  
  
Код \(C++\):

1. Static main\(\)
2. {
3. auto fp, ea;
4. fp = fopen\("pepe.bin","wb"\);
5. for\(ea = 0x400000; ea &lt; 0x40B200; ea++\)
6. fputc\(Byte\(ea\), fp\);
7. }
8. 
В скрипте введём **IMAGEBASE\(БАЗА\_ОБРАЗА\)**, адрес, которой равен **0x400000** и наибольший адрес последней секции исполняемого файла, который мы видим в **IDA** на вкладке **SEGMENTS**, который нужно **СДАМПИТЬ**. В этом случае секция **OVERLAY**, которая является последней секцией исполняемого файла, заканчивается по адресу **0x40B200**.  
  
![2.png](https://wasm.in/attachments/2-png.1539/)   
  
![3.png](https://wasm.in/attachments/3-png.1540/)   
  
Сохраним этот скрипт под каким-нибудь именем, например **DUMPER.IDC**  
  
![4.png](https://wasm.in/attachments/4-png.1541/)   
  
И запускаем его через **FILE → SCRIPT** **FILE**. Можно видеть, что **IDA** принимает скрипты как **PYTHON** так и свои родные **IDC**, поэтому тут с этим нет проблем.  
  
![5.png](https://wasm.in/attachments/5-png.1542/)   
  
Я делаю копию созданного файла и переименовываю его расширение в **EXE**. \(Если Вы не видите расширения файлов, Вы должны изменить соответствующую опцию в **НАСТРОЙКАХ** **ПРОВОДНИКА**\)  
  
![6.png](https://wasm.in/attachments/6-png.1543/)   
  
![7.png](https://wasm.in/attachments/7-png.1544/)   
  
Видим, что у файла нет иконки, потому что некоторые шаги пропущены.  
  
Во вложении приложен **PE** **EDITOR 1.7**, распакуем и запустим его.  
  
![8.png](https://wasm.in/attachments/8-png.1545/)   
  
Теперь идём в **СЕКЦИИ**.  
  
![9.png](https://wasm.in/attachments/9-png.1546/)   
  
Здесь делаем правый щелчок в каждой из секций и выбираем пункт **DUMPFIXER**.  
  
![10.png](https://wasm.in/attachments/10-png.1547/)   
  
![11.png](https://wasm.in/attachments/11-png.1548/)   
  
Видим, что мы уже ближе к победе. По крайней мере, теперь, выводится иконка, хотя программа ещё не запускается, потому что необходимо отремонтировать **IAT**.  
  
**ЧТО ТАКОЕ IAT?**  
  
**IAT** или **IMPORT** **ADDRESS** **TABLE** - это таблица, находящаяся в исполняемом файле, она используется, когда запускается программа. В ней программа сохраняет адреса импортируемых функций, которые она использует, для того, чтобы программа смогла запуститься на любом компьютере.  
  
Если **IAT** верная и если мы дадим исполняемый файл другому человеку, **IAT** будет заполнена значениями, соответствующими конкретному компьютеру, независимо от версии **WINDOWS**, который он имеет, и будет оставаться совместимым, и хорошо работать.  
  
**IAT** будет находиться в определенном месте, в каждом исполняемом файле, и она будет иметь фиксированные позиции для каждой функции, чтобы заполнять их.  
  
Мы помним из предыдущей части, что я хотел объяснить различие между верхним изображением, которое принадлежит упакованному файлу, когда он был в **OEP** перед **ДАМПОМ** и исходного файла.  
  
![12.png](https://wasm.in/attachments/12-png.1549/)   
  
Оба изображения показывают адрес **0x403238** и похоже, что они имеют одинаковое содержимое. Сейчас, давайте откроем оригинальный файл.  
  
![13.png](https://wasm.in/attachments/13-png.1550/)   
  
Здесь можно видеть **ФАЙЛОВОЕ СМЕЩЕНИЕ**, которое равно **0x1038**, чтобы иметь возможность искать данные в **HXD** в исходном исполняемом файле.  
  
Давайте откроем с помощью **HXD** оригинальный файл.  
  
![14.png](https://wasm.in/attachments/14-png.1551/)   
  
Видим, что содержимое памяти по смещению **0x1038** равно **0x355E**.  
  
Если я прибавлю значение **0x355E** к **IMAGEBASE**, которое равно **0x400000**, то получу результат **0x40355E**. Что существует по этому адресу?  
  
Чтобы увидеть что там находиться, нужно загрузить исходный файл с помощью опции **MANUAL** **LOAD**, для того, чтобы **IDA** загрузила все секции исполняемого файла.  
  
![15.png](https://wasm.in/attachments/15-png.1552/)   
  
Соглашаемся со всеми секциями для загрузки и когда файл загрузится, идём по адресу **0x40355E** и видим в правой стороне имя **API** функции, оно равно **GetModuleHandleA**.  
  
![16.png](https://wasm.in/attachments/16-png.1553/)   
  
Итак, когда система загружает файл, программа начинает работать со всеми этими блоками. \(**1** блок — это одна **API** функция. Прим. Яши\) Их можно увидеть ниже на изображении.  
  
![17.png](https://wasm.in/attachments/17-png.1554/)   
  
И каждый блок складывается с содержимым **IMAGEBASE** и ищет соответствующую функции строку. И из этой строки рассчитывается во время выполнения адрес для нашего компьютера. Как например в нашем случае ищется адрес **API** функции **GetModuleHandleA** на нашем компьютере и изменяется значение **5E** **35** на адреса **API**.  
  
Вот почему исполняемый файл работает на любом компьютере, потому что он всегда будет находить в каждой записи **IAT** имя соответcтвующей **API** функции и рассчитывать её адрес при загрузке программы. Таким образом всегда содержащийся в нём адрес будет действительным, хотя и будет отличаться от компьютера к компьютеру. Однако адрес блока **GetModuleHandleA** на всех компьютерах будет одинаковым во всех исполняемых файлах без рандомизации. Изменится только его содержимое.  
  
Вот почему на любом компьютере, если я сделаю:  
  
**CALL \[0x403238\]**  
  
Это всегда будет работать, потому что адрес **0x403238** - это запись **IAT** для функции **GetModuleHandleA**. Что будет меняться - это содержимое, которое система будет сохранять, изменив исходное значение **5E** **35**, которое указывает на строку, если мы сложим её с базой.  
  
Не закрывая две других **IDA** с упакованным файлом, который остановлен в **OEP** и исходным файлом, в третьей **IDA** я открываю **ДАМП**, который мы только что сделали. Это файл **PEPE** - **COPY**.**EXE**.  
  
В этом файле идём в **IAT** по адресу **0x403238**.  
  
![18.png](https://wasm.in/attachments/18-png.1555/)   
  
Видим, что здесь смещение файла равно **0x3238** и оно не соответствует исходному файлу, потому что **DUMPFIXER** который исправлял **RAWSIZE** и **VIRTUALSIZE**, также изменил смещения, и запись **IAT** **API** **GMHA\(**GMHA = GetModuleHandleA прим. Яши**\)**.  
  
Если откроем этот файл в **HXD** и перейдём по адресу **0x3238**.  
  
![19.png](https://wasm.in/attachments/19-png.1556/)   
  
То по этому адресу увидим:  
  
![20.png](https://wasm.in/attachments/20-png.1557/)   
  
Видим, что здесь у нас есть адрес **API** функции, а не смещение, которое нужно сложить с **IMAGEBASE,** чтобы получился адрес **API**.  
  
Когда система запускает упакованный файл, то рассчитываются адреса **API** функций и сохраняются в таблице. При дампинге эти адреса остаются также в этой таблице.  
  
![21.png](https://wasm.in/attachments/21-png.1558/)   
  
Так в чём же проблема?  
  
Когда программа запускается, она ищет в записи **IAT** значение, чтобы сложить его с **IMAGEBASE** и найти строку, чтобы рассчитать адрес, но сейчас значение поломано, потому что при дампинге был сохранен итоговый адрес, и программа будет “падать” при запуске, и будет неспособна правильно заполнить **IAT**.  
  
Хорошо, чтобы закончить с этой темой, давайте подведём итог. Идея состоит в том, чтобы исправить **IAT** и восстановить все эти смещения, которые указывали на строки с именами **API**. Это не надо делать вручную, так как так будет очень долго. Чтобы сделать это быстрее, будем использовать утилиту под названием **SCYLLA**.  
  
Забрать её можно здесь.  
  
[https://tuts4yoututs4you.com/download.php?view.3503](https://tuts4yoututs4you.com/download.php?view.3503)  
  
Пароль на архив **RAR** равен **tuts4you**  
  
![22.png](https://wasm.in/attachments/22-png.1559/)   
  
Я запускаю нашу распакованную **SCYLLA**.  
  
![23.png](https://wasm.in/attachments/23-png.1560/)   
  
В пункте **ATTACH** **TO** **ACTIVE** **PROCESS** из выпадающего меню я выбираю процесс упакованного файла, который остановлен в **IDA** на **OEP**.  
  
![24.png](https://wasm.in/attachments/24-png.1561/)   
  
Теперь меняем в программе **OEP** на значение **401000.**  
  
![25.png](https://wasm.in/attachments/25-png.1562/)   
  
И нажимаем кнопку **IAT AUTOSEARCH.**  
  
![26.png](https://wasm.in/attachments/26-png.1563/)   
  
Программа говорит нам, что таблица **IAT** начинается по адресу **0x403184** и её размер равен **0x108**.  
  
После этого, давайте нажмём кнопку **GET IMPORTS**.  
  
![27.png](https://wasm.in/attachments/27-png.1564/)   
  
Видим, что **SCYLLA** нашла все адреса, за исключением трёх вхождений. Она показывает плохие записи после нажатия кнопки **SHOW INVALID.**  
  
![28.png](https://wasm.in/attachments/28-png.1565/)   
  
С другой стороны, видим, что смещение **3238** в упакованном файле принадлежало, соответственно, функции **GetModuleHandleA** и мы знали про это. Программа очень правильно рассчитало значение. Мы можем посмотреть в упакованном файле недействительные адреса записи **0x403248** в дальнейшем, чтобы увидеть, что они собой представляют.  
  
![29.png](https://wasm.in/attachments/29-png.1566/)   
  
Видим, что эта запись принадлежит библиотеке **COMCTRL32**.  
  
И если я сделаю правый щелчок на неправильных записях в **SCYLLA** и выберу **SCYLLA** **PLUGIN →** **PE** **COMPACT**, она исправит эти ошибки.  
  
![30.png](https://wasm.in/attachments/30-png.1567/)   
  
Теперь записи совпадают с теми, которые мы только что видели.  
  
![31.png](https://wasm.in/attachments/31-png.1568/)   
  
Если нажмём кнопку **SHOW** **SUSPECT**, можем увидеть, верны ли эти два подозрительных вызова по адресам **0x403258** и **0x403278**.  
  
![32.png](https://wasm.in/attachments/32-png.1569/)   
  
Да, они получаются правильными. Так что, теперь, можем нажать кнопку **FIX DUMP.**  
  
![33.png](https://wasm.in/attachments/33-png.1570/)   
  
**SCYLLA** сохранит записи в починенный файл **PEPE-COPY\_SCY.EXE**, и теперь видно, что он работает.  
  
![34.png](https://wasm.in/attachments/34-png.1571/)   
  
Открыв этот распакованный файл в **IDA**, видим, что теперь **OEP** начинается по адресу **0x401000** и что имена похожи на имена **API** как в исходном файле, так что всё рассчитались правильно.  
  
![35.png](https://wasm.in/attachments/35-png.1572/)   
  
![36.png](https://wasm.in/attachments/36-png.1573/)   
  
Таблица **IAT** выглядит также хорошо, как и у исходного файла.  
  
Хорошо, мы распаковали наш первый и простой упаковщик. Позже мы увидим другие, более сложные упаковщики.  
  
До встречи в **16**-той части.  
  
  
====================================================================  
Автор текста: **Рикардо Нарваха** - **Ricardo** **Narvaja** \(**@ricnar456**\)  
Перевод на английский: **IvinsonCLS \(@IvinsonCLS\)**  
Перевод на русский с испанского+английского: **Яша\_Добрый\_Хакер\(Ростовский фанат Нарвахи\).**  
Перевод специально для форума системного и низкоуровневого программирования - **WASM.IN  
22.09.2017  
Версия 1.0**

