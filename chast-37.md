# Часть 37

 Хорошо. Мы будем делать тот же пример, который мы делали в предыдущей части, но на этот раз используя плагин **MONA** внутри отладчика **WINDBG**. Мы знаем, что **MONA** не запускается в **IDA**. Поэтому мы открываем **WINDBG** вне **IDA**.  
  
Я запускаю файл **DEP**.**EXE** из консоли с несколькими аргументами, чтобы он не закрывался. Программа будет ожидать ввода данных с клавиатуры.  
  
![1.png](https://wasm.in/attachments/1-png.2868/)   
  
Я мог бы запустить программу также и с помощью **WINDBG**. Это было бы те же самым. Нам просто нужно остановиться в том месте, где загружается **DLL**, в которую мы будем загружать **ROP**. Не имеет значения, что он не заработает.  
  
В этом случае, мы находимся внутри функции **GETS\_S** и библиотека **MYPEPE** уже загружена.  
  
![2.png](https://wasm.in/attachments/2-png.2869/)   
  
Я присоединяюсь к процессу через пункт **FILE** → **ATTACH** **TO** **PROCESS**.  
  
![3.png](https://wasm.in/attachments/3-png.2870/)   
  
Загрузка символов не имеет большого значения для нас. Но хорошо, мы уже находимся в нужном месте.  
  
![4.png](https://wasm.in/attachments/4-png.2871/)   
  
Символы уже присутствуют.  
  
Хорошо, давайте загрузим **MONA**.  
  
![5.png](https://wasm.in/attachments/5-png.2872/)   
  
Сейчас, давайте попросим её сделать нам **ROP** для библиотеки **MYPEPE**.**DLL**. Давайте посмотрим, какой результат получился у неё.  
  
**!PY** **MONA** **ROP -M** **MYPEPE**  
  
Давайте пойдем за кофе, пока **MONA** работает над поставленной задачей. Это займет немного времени.  
  
Пока она заканчивается анализ, позвольте мне сказать, что у неё есть опции для поиска адресов без нулей, для фильтрации различных символов, и т.д. Это очень хорошо. Хотя она не всегда находит полную цепочку **ROP**. Иногда, **MONA** даёт нам почти полный **ROP** и говорит нам, чего ей не хватает, для того, чтобы найти цепочку вручную. Поэтому нам всегда приходится немного доделывать за неё работу.  
  
![6.png](https://wasm.in/attachments/6-png.2873/)   
  
Тсссссссс...... Дайте ей время подумать.  
  
![7.png](https://wasm.in/attachments/7-png.2874/)   
  
Опция **-CP** даёт нам возможность фильтровать результаты **ROP** в соответствии с различными критериями. Мы видим, что у **MONA** есть опция **NONULL** для того, чтобы найти инструкции без нулей или другие. Также у неё есть возможность фильтровать численно с помощью опции **CPB**, для определенных символов.  
  
![8.png](https://wasm.in/attachments/8-png.2875/)   
  
**MONA** закончила анализ. Посмотрим на результат. Она написала много текста. Если бы я запустил её как пользователь **ADMINISRATOR**, она сохранила бы результат в **TXT** **ФАЙЛ,** но у неё нет разрешений на запись. Поэтому я буду копировать здесь наиболее интересные части.  
  
![9.png](https://wasm.in/attachments/9-png.2876/)   
  
Мы видим, что она показывает нам то, что регистры должны иметь перед гаджетом **PUSHAD** **-** **RET**, который мы использовали в предыдущей части. Она даёт нам ещё одну альтернативу для вызова функции **VIRTUALALLOC**. Также полезно сохранить то, что должны иметь регистры при использовании функции **VIRTUALPROTECT** которая также находится там.  
  
![10.png](https://wasm.in/attachments/10-png.2877/)   
  
Хорошо это сохранить. В случае, если мы сделаем это вручную, мы сможем узнать, что назначить каждому регистру перед **PUSHAD** - **RET** для **VIRTUALALLOC** и **VIRTUALPROTECT**. Теперь, давайте посмотрим, нашла ли она **ROP** для функции **VIRTUALALLOC**.  
  
![11.png](https://wasm.in/attachments/11-png.2878/)   
  
Мы видим, что **MONA** нашла **ROP** и упростила его, потому что она использовала другой способ, который напрямую использует другую записать **IAT**, а не адрес **API**. Программа переходит косвенно и избегает передачи адресов **VA** между регистрами.  
  
Здесь мы видим, что это уже код для **PYTHON**. Поэтому мы копируем и вставляем его в наш скрипт.  
  
Мы видим, что питон определяет функцию. Поэтому я буду копировать и вставлять код в начало моего скрипта.  
  
![12.png](https://wasm.in/attachments/12-png.2879/)   
  
И мы будем вызывать **ROP** с помощью функции  
  
**ROP\_CHAIN = CREATE\_ROP\_CHAIN\(\)**  
  
Мы будем добавлять этот код в основную часть моего скрипта, для того, чтобы возвратится назад в **ROP**.  
  
Давайте посмотрим, сработает ли этот код.  
  
Что-то ничего не получилось. Это не странно. Мы будем трассировать **ROP** и увидим, что случится.  
  
![13.png](https://wasm.in/attachments/13-png.2880/)   
  
Мы уже присоединились к процессу с помощью **IDA**. Теперь мы можем использовать её. Нам не нужна **MONA**.  
  
![14.png](https://wasm.in/attachments/14-png.2881/)   
  
Давайте посмотрим, что нам нужно присвоить каждому регистру.  
  
![15.png](https://wasm.in/attachments/15-png.2882/)   
  
Это альтернативный подход, который используется и мы видим разницу легче, потому что **MONA** помещает инструкцию **JMP** \[**EAX**\] в регистр **ESI** а тот, который я использовал, помещает адрес функции **VA** в регистр **ESI.**  
  
Давайте потрассируем код, чтобы увидеть, что случиться.  
  
Это наш первый гаджет.  
  
![16.png](https://wasm.in/attachments/16-png.2883/)   
  
Регистр должен указывать на инструкцию **POP**, чтобы пропустить **4** байта. Давайте выполним эту инструкцию и посмотрим что осталось в регистре **EBP**.  
  
Последний адрес этого гаджета **POP EBP - RET** находится в регистре **EBP**.  
  
Это хорошо.  
  
![17.png](https://wasm.in/attachments/17-png.2884/)   
  
Перейдем к следующему гаджетом.  
  
![18.png](https://wasm.in/attachments/18-png.2885/)   
  
Гаджет помещает в регистр **EBX** значение **1**, которое является **DWSIZE**. Поэтому он соответствует нашей модели. Давайте продолжим.  
  
![19.png](https://wasm.in/attachments/19-png.2886/)   
  
Этот гаджет поместит в регистр **EDX** значение **0x1000** как говорит наша модель. Давайте продолжим.  
  
![20.png](https://wasm.in/attachments/20-png.2887/)   
  
Этот гаджет поместит в регистр **ECX** значение **40**. Все нормально. Давайте продолжим.  
  
![21.png](https://wasm.in/attachments/21-png.2888/)   
  
Дальше гаджет не заработал. Он переходит в любое место и не следует цепочке **ROP**, как и следовало ожидать, потому что следующий не существует. Это обычно происходит когда есть какой-то недопустимый символ, который мы не увидели, который отрезает запись байтов. Давайте посмотрим, что следует сделать.  
  
![22.png](https://wasm.in/attachments/22-png.2889/)   
  
Здесь гаджет был урезан. У нас есть **0x1A**. Может быть, коду не нравится это значение? Давайте найдем другую инструкцию **POP** **EDI** у которой нет байта **0x1A** чтобы узнать что произойдет.  
  
По адресу **0x78028756** находится инструкция **POP** **EDI**, которую я нашел в предыдущей части. Мы будем использовать это адрес.  
  
![23.png](https://wasm.in/attachments/23-png.2890/)   
  
Давайте потрассируем цепочку снова.  
  
![24.png](https://wasm.in/attachments/24-png.2891/)   
  
Цепочка отработала и вы видите **ROP**, который теперь в стеке. Сейчас она не была урезана. Давайте посмотрим, что гаджет сохранил в регистр **EDI**.  
  
Это указатель на **C3** или **RET** как говорит наша модель.  
  
![25.png](https://wasm.in/attachments/25-png.2892/)   
  
Мы видим, что после инструкции **POP** **ESI**, **ESI** указывает на инструкцию **JMP** \[**EAX**\] как говорится в нашей модели.  
  
![26.png](https://wasm.in/attachments/26-png.2893/)   
  
В регистре **EAX** должна остаться запись на **VA IAT**, а не адрес.  
  
![27.png](https://wasm.in/attachments/27-png.2894/)   
  
Это была корректная запись **VA IAT**, но если мы продолжим программа выдаст ошибку.  
  
![28.png](https://wasm.in/attachments/28-png.2895/)   
  
Если я продолжу, я увижу, что ошибка, в этом случае, создается из-за инструкции **ADD** **AL**, **80** которая добавляется к адресу **VA IAT**. Поэтому для компенсации мы должны вычесть **0x80** из адреса записи **IAT**.  
  
![29.png](https://wasm.in/attachments/29-png.2896/)   
  
**Python&gt;HEX\(0x7802E0B0 – 0x80\)**  
  
**0x7802E030**  
  
![30.png](https://wasm.in/attachments/30-png.2897/)   
  
Сейчас гаджет должен сработать.  
  
![31.png](https://wasm.in/attachments/31-png.2898/)   
  
Мы увидели, как хорошо помогает нам **MONA**. Она даёт нам почти все верные ответы, но иногда нам нужно что-то подкорректировать вручную. Это не всегда идеально. В любом случае, когда у нас мало времени, мы обычно делаем это так. Хотя это и не так весело и интересно.  
  
**=======================================================  
Автор текста: Рикардо Нарваха** - **Ricardo** **Narvaja** \(**@ricnar456**\)  
Перевод на английский: **IvinsonCLS \(@IvinsonCLS\)**  
Перевод на русский с испанского+английского: **Яша\_Добрый\_Хакер\(Ростовский фанат Нарвахи\).**  
Перевод специально для форума системного и низкоуровневого программирования — **WASM.IN  
25.03.2018  
Версия 1.0**

