# Часть 57

 Хорошо. Мы будем пытаться эксплуатировать переполнение стека из скрипта **PYTHON**. Обычно эксплуатация ядра происходит локально. Другими словами, скрипт уже эксплуатирует некоторую программу, которая не имеет привилегий системы и хочет повысить привилегии и быть с правами **SYSTEM**, что устраняет ограничения, которые имеет эксплуатируемый процесс, который имеет только ограниченные привилегии обычного пользователя на машине.  
  
Поэтому, за исключением очень редких исключений, эксплойты ядра - это эксплоиты для повышения привилегий или **PRIVILEDGE** **ESCALATION**.  
  
Поэтому, много раз мы будм видеть их код в скомпилированном исполняемом файле или их исходный код, потому что предполагается, что мы должны загрузить файл и запустить его с правами обычного пользователя. Этот исполняемый файл будет атаковать в этом случае наш драйвер и проэксплуатириует его достигнув эскалации.  
  
В любом случае, как код в **C**, так и код на **PYTHON** основаны на вызовах одних и тех же **WINDOWS** **API**, таких, как **CREATEFILE**, **DEVICEIOCONTROL** и т.д. Поэтому, то, что делается на одном языке, легко переносится на другой.  
  
Давайте напомним нашу модель **PYTHON** предыдущего примера.  
  
![1.png](https://wasm.in/attachments/1-png.4024/)  
  
Первым шагом будет изменение имени для драйвера поэтому, когда вы делаете **CREATEFILE**, нам возвратится его правильный дескриптор.  
  
Напомним, что имя генерируется здесь  
  
![2.png](https://wasm.in/attachments/2-png.4025/)   
  
![3.png](https://wasm.in/attachments/3-png.4026/)   
  
Здесь драйвер возвращает **SYMBOLICNAME**, который приходит из строки, которая находится в **DEVICENAME**.  
  
![4.png](https://wasm.in/attachments/4-png.4027/)   
  
Без особых проблем, конечно, если я заменяю имя старого драйвера драйвером новым.  
  
![5.png](https://wasm.in/attachments/5-png.4028/)   
  
Мы можем скопировать его на целевую машину и посмотреть, не даст ли он мне ошибку или даст действительный дескриптор, но я буду продолжать смотреть.  
  
Этот драйвер запущен, и я запускаю скрипт.  
  
![6.png](https://wasm.in/attachments/6-png.4029/)   
  
Поскольку **SYMBOLICLINK** идет отсюда, имеет смысл использовать это имя.  
  
![7.png](https://wasm.in/attachments/7-png.4030/)   
  
Давайте попробуем так.  
  
![8.png](https://wasm.in/attachments/8-png.4031/)   
  
Мы видим, что всё работает.  
  
![9.png](https://wasm.in/attachments/9-png.4032/)   
  
Мне вернулось положительное значение, которое является дескриптором драйвера. Остальное меня не интересует, поэтому я закрываю его.  
  
![10.png](https://wasm.in/attachments/10-png.4033/)   
  
На данный момент, мы удаляем **WHILE** и все остальное, что нас не интересует. Следующая вещь заключается в том, чтобы увидеть, какой именно **IOCTL** переносит нас в блок переполнение стека, чтобы отправить его.  
  
Вопрос состоит в том, как добраться туда.  
  
![11.png](https://wasm.in/attachments/11-png.4034/)   
  
Мы видим, что драйвер идёт отсюда.  
  
![12.png](https://wasm.in/attachments/12-png.4035/)   
  
Регистр **EDX** имеет код **IOCTL**, который получается отсюда.  
  
![13.png](https://wasm.in/attachments/13-png.4036/)   
  
Программа сделает вычитание из регистра значения **0x222003**, и если результатом будет нуль, мы перейдем к той части, которая нам нужна.  
  
Давайте посмотрим, достигнет ли программа блока, где мы хотим присоединить **IDA** и устанавливаем **BP**.  
  
![14.png](https://wasm.in/attachments/14-png.4037/)   
  
Я запускаю драйвер на целевой машине и попадаю в **BP.**  
  
![15.png](https://wasm.in/attachments/15-png.4038/)   
  
Мы видим, что в регистр **EDX** драйвер считывает **IOCTL** код, который он передает.  
  
![16.png](https://wasm.in/attachments/16-png.4039/)   
  
![17.png](https://wasm.in/attachments/17-png.4040/)   
  
Программа помещает результат в регистр **EAX,** вычитает из него значение **0x222003** и поскольку результатом будет нуль, драйвер переходит в уязвимый блок.  
  
![18.png](https://wasm.in/attachments/18-png.4041/)   
  
![19.png](https://wasm.in/attachments/19-png.4042/)   
  
Программа читает длину, которая является нулем, так как я не передал ей аргументы за исключением **IOCTL**.  
  
![20.png](https://wasm.in/attachments/20-png.4043/)   
  
Поскольку аргумент равен нулю, программа пропускает функцию, в которой происходит переполнение стека.  
  
![21.png](https://wasm.in/attachments/21-png.4044/)   
  
Поскольку **API** функция, вызывается из **WIN32FILE** в **PYTHON**, она имеет меньше аргументов, чем исходная функция, которая имеет больше.  
  
![22.png](https://wasm.in/attachments/22-png.4045/)   
  
![23.png](https://wasm.in/attachments/23-png.4046/)   
  
Здесь находится определение **WIN32FILE** **PYTHON.**  
  
![24.png](https://wasm.in/attachments/24-png.4047/)  
  
Мы увидим, что если мы достигли этого места, нам нужно сделать буфер, чтобы передать его на вход, так как поскольку нам нужен указатель на него, мы можем сделать это с помощью функции **ALLOCATEREADBUFFER**, которая выделяет нам в куче количество памяти, которое нам нужно передать входному буферу. \(Другая опция **WIN32FILE** не дает нам\).  
  
![25.png](https://wasm.in/attachments/25-png.4048/)  
  
Поскольку библиотека **WIN32FILE** не имеет доступа ко всем **API**, она не позволяет копировать непосредственно в буфер как функция **MEMCPY** или что-то вроде этого, поэтому мы можем копировать его только с помощью функции **READFILE**, поэтому мы делаем файл **PEPE**.**BIN**, заполняя его **0x1000** буквами **A**. Мы передаем файл в функцию **CREATEFILE**, чтобы она открывала его и вернула нам дескриптор, и мы передали его в функцию **READFILE** с аргументом **BUF** буфера, который мы выделяем и копировать содержимое файла туда.  
  
Очевидно, что если мы сделаем это на **C,** **C++** или языке, в котором мы можем использовать функцию **VIRTUALALLOC** и легко копировать с помощью функции **MEMCPY** или той которую мы хотим. Но здесь у нас есть определенные ограничения, и мы должны приспосабливаться к этому.  
  
Нам нужно дополнительно знать, какую длину мы должны отправить. Давайте посмотрим на буфер назначения в **IDA**.  
  
![26.png](https://wasm.in/attachments/26-png.4049/)   
  
Мы замечаем, что с начала буфера до адреса возврата получается **520** десятичных байт \* **4** размер элемента.  
  
Поэтому  
  
hex\(520\*4\) = '0x820'  
  
Поэтому мы должны отправить **0x820** + **RET.**  
  
Сейчас, поскольку мы знаем в **PYTHON** адрес буфера, который мы создаем, чтобы передавать его, мы будем использовать грязный трюк - **REPR**.  
  
![27.png](https://wasm.in/attachments/27-png.4050/)   
  
Мы видим, что функция возвращает адрес, в который я могу писать. В одной строке. Поэтому я ищу сначала **0x**, затем ищу запятую в этой строке, и я могу разбить адрес.  
  
![28.png](https://wasm.in/attachments/28-png.4051/)   
  
![29.png](https://wasm.in/attachments/29-png.4052/)   
  
Здесь cуществует адрес, который мы можем передать с помощью **STRUCT**.**PACK** после **0x820** **A**. Досадно, что мы должны записать их в файл, который читается.  
  
Следовательно, как только у меня есть адрес буфер.  
  
![30.png](https://wasm.in/attachments/30-png.4053/)   
  
Я пишу в файл **ФРУКТЫ**, которые хочу отправить.  
  
![31.png](https://wasm.in/attachments/31-png.4054/)   
  
Перед функцией **READFILE** скопируем их в буфер.  
  
Давайте посмотрим, заработает ли это. В этом случае нет необходимости иметь файл, потому что он будет создан и заполнен, поэтому мы удалили предыдущий.  
  
![32.png](https://wasm.in/attachments/32-png.4055/)  
  
Для этого мы изменили аргумент на **CREATE** **ALWAYS.**  
  
![33.png](https://wasm.in/attachments/33-png.4056/)   
  
Хорошо. Предположительно здесь - наш буфер с буквами **A**. **IDA** остановлена. Давайте посмотрим, что я передаю.  
  
![34.png](https://wasm.in/attachments/34-png.4057/)   
  
Мы видим, что входной буфер, который передается в регистр **EDX**, показывает нам то же самое значение. Давайте посмотрим, есть ли там **A**.  
=======================================================================  
![35.png](https://wasm.in/attachments/35-png.4058/)   
=======================================================================  
![36.png](https://wasm.in/attachments/36-png.4059/)   
=======================================================================  
Он не заполнился буквами A. Давайте пропустим эксплуатацию и давайте исправим скрипт.  
  
![37.png](https://wasm.in/attachments/37-png.4060/)   
  
Я меняю **EIP** здесь с помощью правой кнопки и **SET** **IP** и нажимаю **RUN**.  
  
Я думаю, что проблема в том, что размер буфера должен соответствовать размеру файла.  
  
![38.png](https://wasm.in/attachments/38-png.4061/)   
  
Давайте сделаем так.  
  
Ах, уже упал.  
  
![39.png](https://wasm.in/attachments/39-png.4062/)   
  
Скрипту не хватало установки указателя файла в начале файла. Он читал файл с конца, где я оставил **WRITEFILE**, поэтому я не читал **A.** Теперь всё работает.  
  
![40.png](https://wasm.in/attachments/40-png.4063/)   
  
Я трассирую до **MEMCPY**.  
  
![41.png](https://wasm.in/attachments/41-png.4064/)   
  
Я добираюсь до **RET**.  
  
![42.png](https://wasm.in/attachments/42-png.4065/)   
  
Я продолжаю с помощью **F7**.  
  
![43.png](https://wasm.in/attachments/43-png.4066/)   
  
Я вижу, что я попал в буфер. Проблема состоит в том, что, поскольку я не выделил его с помощью **VIRTUALALLOC**, а выделяю его с помощью **API** **ALLOCATEREADBUFFER**, **WIN32FILE** у него нет прав на выполнение. Поэтому мне придется найти способ выделить исполняемый код другим способом.  
  
![44.png](https://wasm.in/attachments/44-png.4067/)   
  
Я добавил библиотеку **CTYPES**, и у неё есть функция **VIRTUALPROTECT**, поэтому я дал ей права на выполнение, и теперь у нас нет проблем.  
  
![45.png](https://wasm.in/attachments/45-png.4068/)   
  
Программа переходит и выполняет без проблем. Я действительно вижу, что **CTYPES** более продвинутая, чем **WIN32API**, поэтому вы можете делать все, вызывает прямо функцию **VIRTUALALLOC**непосредственно из **CTYPES.**  
  
Версия c **CTYPES** – это так  
  
![46.png](https://wasm.in/attachments/46-png.4069/)  
  
Библиотека использует напрямую функции **CREATEFILE**, **VIRTUALALLOC**, **RTLMOVENEMORY** и **DEVICEIOCONTROL.** Вам просто нужно быть осторожным с одним из типов, но она работает хорошо.  
  
![47.png](https://wasm.in/attachments/47-png.4070/)   
  
Здесь всё работает. Вопрос сейчас состоит в том, что мы выполняем код. Нам осталось бы делать шеллкод, потому что так у нас будет только красивый синий экран.  
  
Мы проанализируем шеллкод и создадим его в следующей части.  
  
**=======================================================  
Автор текста: Рикардо Нарваха** - **Ricardo** **Narvaja** \(**@ricnar456**\)  
Перевод на русский с испанского: **Яша\_Добрый\_Хакер\(Ростовский фанат Нарвахи\).**  
Перевод специально для форума системного и низкоуровневого программирования — **WASM.IN  
03.11.2018  
Версия 1.0**

