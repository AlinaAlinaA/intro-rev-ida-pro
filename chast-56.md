# Часть 56

Давайте теперь рассмотрим драйвер, который запрограммирован с различными уязвимостями, чтобы понять, как их эксплуатировать. Как и всегда мы будем использовать **WINDOWS** **7** **SP1** без какого-либо патча безопасности. Мы знаем, что здесь всё будет работать. Затем мы увидим, какие изменения есть ниже и какие другие возможности существуют в новых системах. Но мы будем идти потихоньку и никуда не будем спешить.

У нас есть драйвер, скомпилированный с символами. У вас есть возможность эксплуатировать его практически всеми возможными способами. Он сделан специально для практики.

[https://github.com/hacksysteam/HackSysExtremeVulnerableDriver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver)

**Реализованные уязвимости**

* **Двойная выборка**
* **Переполнение пула**
* **Использование после освобождения**
* **Путаница в типах**
* **Переполнение стека**
* **Целочисленное переполнение**
* **Переполнение стека с флагом GS\(Buffer Security Check\)**
* **Перезапись арбитражного кода**
* **Разыменование нулевого указателя**
* **Неинициализированная переменная кучи**
* **Неинициализированная переменная стека**
* **Небезопасный доступ к ресурсам ядра**

Мы будем начинать потихоньку. Сначала сделаем анализ переполнения стека.

Конечно, Вам нужно скопировать драйвер на целевую машину и загрузить его с помощью **OSR** **DRIVER LOADER**.

Мы копируем его с его **IDB** в локальную папку и открываем его в **IDA** чтобы начать анализ.

Хорошо. Как мы уже знаем здесь, у нас есть символы, которые облегчают нам много вещи. Но первое, что мы должны найти и что почти всегда распознаётся с символами или без, это структура \_**DRIVER**\_**OBJECT**, которая передается как аргумент в функцию **DRIVERENTRY**.

В этом случае у нас не так много проблем.

![](.gitbook/assets/56/01.png)

Здесь хорошо видна точка входа, и ее аргументы хорошо обнаружились.

Мы видим, что драйвер использует, как и в предыдущих примерах, **API** функцию **RTLINITUNICODESTRING** для инициализации структур.

![](.gitbook/assets/56/02.png)

Напомним, что первым аргументом был указатель на структуру **UNICODE**\_**STRING**. Здесь мы видим **PUNICODE**\_**STRING,** т.е. указатель на структуру **UNICODE**\_**STRING**.

![](.gitbook/assets/56/03.png)

Т.е. это буфер, куда драйвер сохранит длину строки в переменную типа **WORD,** Максимальная длина в следующем поле также имеет тип **WORD**, а указатель будет скопирован в строку юникода, которую мы передали как источник в третьем поле.

![](.gitbook/assets/56/04.png)

Сначала инициализируется в нуль структура **DOSDEVICENAME**, которая также имеет тип **UNICODE**\_**STRING**.

![](.gitbook/assets/56/05.png)

Драйвер помещает в поле **LENGTH** нуль, помещая в него значение регистра **AX**, которое равно здесь **0.** А затем идет инструкция **STOSD,** которая копирует значение из регистра **EAX**, т.е. помещает нуль в адрес, куда указывает регистр **EDI,** т.е. в поле **MAXIMUMLENGHT.** А затем следующая инструкция **STOSW** копирует из регистра **AX** значение**,** т.е. нуль в два следующих байтах, т.е. помещая нуль в **6** байтов, т. е. инициализирует два оставшихся поля структуры, которые занимают **6** байтов \(**1** **WORD** и **DWORD**\).

Компилятор только инициализирует структуру **DOSDEVICENAME.** Другая переменная, которая называется **DEVICENAME**, не равна нулю. Драйвер использует ее напрямую.

![](.gitbook/assets/56/06.png)

Другими словами, **DEVICENAME** - это строка, которая преобразуется в тип структуры **UNICODE**\_**STRING.** Другими словами, в её трех полях будет длина, максимальная длина и указатель, который мы передаем в строку источник. Он будет скопирован в третье поле.

![](.gitbook/assets/56/07.png)

В моей машине указатель находится по адресу **0x00016938**. Это смещение скопирует его в третье поле структуры.

![](.gitbook/assets/56/08.png)

В **DOSDEVICENAME** вы будете создавать другой указатель **UNICODE**\_**STRING**. Я использую как источник эту другую строку.

Затем идёт вызов функции **IOCREATEDEVICE.** Мы помним, что вам нужно было создать **DEVICE** **OBJECT**, чтобы иметь возможность общаться с программами из пользовательского режима.

![](.gitbook/assets/56/09.png)

![](.gitbook/assets/56/10.png)

Это будет почти всегда около точки входа в большинстве драйверов, которые взаимодействуют с программами в пользовательском режиме.

![](.gitbook/assets/56/11.png)

Последний аргумент, это указатель на вновь созданную структуру **DEVICE**\_**OBJECT**.

![](.gitbook/assets/56/12.png)

Мы видим, что если результат создания устройства отрицательный, который проверяется в этом условном знаковом переходе, драйвер переходит к оранжевым блокам ошибок, а объект устройства удаляется с помощью функции **IODELETEDEVICE**.

![](.gitbook/assets/56/13.png)

Затем структура **DRIVEROBJECT** будет инициализироваться из регистра **ESI** + **38.** Поскольку **ESI** указывает на **DRIVEROBJECT**, я нажимаю **T.** Я могу посмотреть, какое это поле \(но это **DRIVER**\_**OBJECT** идём в **LOCAL** **TYPES** и синхронизируем типы\)

![](.gitbook/assets/56/14.png)

![](.gitbook/assets/56/15.png)

Т.е. это указатель на структуру **MAJORFUNCTION**, про которую мы помним, что он представляет собой таблицу указателей, которая, согласно позиции, приведет меня к разным функциям в зависимости от случая. Вспомните это, например.

![](.gitbook/assets/56/16.png)

Первый указатель, т.е. тот, который находится в позиции **0**, является **IRP\_MJ\_CREATE** и драйвер будет переходить на него, когда вы вызываете функцию **CREATEFILE**, чтобы открыть дескриптор устройства. Второй указатель, т.е. со значением **0x1** находится в положении 4**,** так как он являются **DWORD** и т.д. Это означает, что обратно пропорционально, если у меня есть поле этой структуры по её смещению, чтобы знать, какой указатель нам нужен надо делить его на четыре. Из примера, который мы использовали в предыдущих драйверах давайте вспомним.

![](.gitbook/assets/56/17.png)

Это соответствует значению **0x38/4**, т.е.

Python&gt;hex\(0x38/4\)
0xE

![](.gitbook/assets/56/18.png)

Т.е. **0xE** соответствует **IRP\_MJ\_DEVICE\_CONTROL**, когда мы передали код **IOCTL** из режима пользователя. Этот указатель мы перезаписали с помощью обработчика, так что в соответствии с тем, какой код **IOCTL**, различные действия будут выполняться с помощью конструкции **SWITCH**. Например так.

В текущем случае, мы видим, что драйвер инициализирует значения начиная с указателя на начало таблицы **MAJORFUNCTION**. Он копирует значение регистра **EAX**, в которое помещается смещение функции, которая называется **\_IRP\_NOTIMPLEMENTEDHANDLERS.** Копирование происходит **0x1C** раз. Это значение передаётся в регистре **ECX.** Оно равно количеству указателей, которые нужно инициализировать.

![](.gitbook/assets/56/19.png)

Другими словами, в начале вся таблица инициализирует этим указателем, который, по-видимому, не будет делать ничего. Это похоже на случай по умолчанию.

![](.gitbook/assets/56/20.png)

Поскольку регистр **EDX** хранит указатель на начало таблицы **MAJORFUNCTION**, его содержимым является позиция **0**, т.е.

+\#define IRP\_MJ\_CREATE 0x00
+\#define IRP\_MJ\_CREATE\_NAMED\_PIPE 0x01
+\#define IRP\_MJ\_CLOSE 0x02
+\#define IRP\_MJ\_READ 0x03
+\#define IRP\_MJ\_WRITE 0x04
+\#define IRP\_MJ\_QUERY\_INFORMATION 0x05
+\#define IRP\_MJ\_SET\_INFORMATION 0x06
+\#define IRP\_MJ\_QUERY\_EA 0x07
+\#define IRP\_MJ\_SET\_EA 0x08
+\#define IRP\_MJ\_FLUSH\_BUFFERS 0x09
+\#define IRP\_MJ\_QUERY\_VOLUME\_INFORMATION 0x0a
+\#define IRP\_MJ\_SET\_VOLUME\_INFORMATION 0x0b
+\#define IRP\_MJ\_DIRECTORY\_CONTROL 0x0c
+\#define IRP\_MJ\_FILE\_SYSTEM\_CONTROL 0x0d
+\#define IRP\_MJ\_DEVICE\_CONTROL 0x0e
+\#define IRP\_MJ\_INTERNAL\_DEVICE\_CONTROL 0x0f
+\#define IRP\_MJ\_SCSI 0x0f
+\#define IRP\_MJ\_SHUTDOWN 0x10
+\#define IRP\_MJ\_LOCK\_CONTROL 0x11
+\#define IRP\_MJ\_CLEANUP 0x12
+\#define IRP\_MJ\_CREATE\_MAILSLOT 0x13
+\#define IRP\_MJ\_QUERY\_SECURITY 0x14
+\#define IRP\_MJ\_SET\_SECURITY 0x15
+\#define IRP\_MJ\_POWER 0x16
+\#define IRP\_MJ\_SYSTEM\_CONTROL 0x17
+\#define IRP\_MJ\_DEVICE\_CHANGE 0x18
+\#define IRP\_MJ\_QUERY\_QUOTA 0x19
+\#define IRP\_MJ\_SET\_QUOTA 0x1a
+\#define IRP\_MJ\_PNP 0x1b
+\#define IRP\_MJ\_PNP\_POWER 0x1b
+\#define IRP\_MJ\_MAXIMUM\_FUNCTION 0x1b

Мы будем создавать структуру **MAJORFUNCTION.**

struct \_\_MajorFunction{
unsigned int \_MJ\_CREATE;
unsigned int \_MJ\_CREATE\_NAMED\_PIPE;
unsigned int \_MJ\_CLOSE;
unsigned int \_MJ\_READ;
unsigned int \_MJ\_WRITE;
unsigned int \_MJ\_QUERY\_INFORMATION;
unsigned int \_MJ\_SET\_INFORMATION;
unsigned int \_MJ\_QUERY\_EA;
unsigned int \_MJ\_SET\_EA;
unsigned int \_MJ\_FLUSH\_BUFFERS;
unsigned int \_MJ\_QUERY\_VOLUME\_INFORMATION;
unsigned int \_MJ\_SET\_VOLUME\_INFORMATION;
unsigned int \_MJ\_DIRECTORY\_CONTROL;
unsigned int \_MJ\_FILE\_SYSTEM\_CONTROL;
unsigned int \_MJ\_DEVICE\_CONTROL;
unsigned int \_MJ\_INTERNAL\_DEVICE\_CONTROL;
unsigned int \_MJ\_SCSI;
unsigned int \_MJ\_SHUTDOWN;
unsigned int \_MJ\_LOCK\_CONTROL;
unsigned int \_MJ\_CLEANUP;
unsigned int \_MJ\_CREATE\_MAILSLOT;
unsigned int \_MJ\_QUERY\_SECURITY;
unsigned int \_MJ\_SET\_SECURITY;
unsigned int \_MJ\_POWER;
unsigned int \_MJ\_SYSTEM\_CONTROL;
unsigned int \_MJ\_DEVICE\_CHANGE;
unsigned int \_MJ\_QUERY\_QUOTA;
unsigned int \_MJ\_SET\_QUOTA;
unsigned int \_MJ\_PNP;
unsigned int \_MJ\_PNP\_POWER;
unsigned int \_MJ\_MAXIMUM\_FUNCTION;
};

Я знаю, что это указатели, но для нашего случая я буду использовать тип **UNSIGNED** **INT** и это будет работать. Проблема состоит в том, что это локальные типы. При использовании операции **INSERT**, **IDA** не принимают структуру. Поэтому я буду экспортировать её. Я добавляю структуру и перезагружаю ее с помощью **FILE→** **LOAD FILE→** **PARSE C HEADER FILE**

![](.gitbook/assets/56/21.png)

Я добавил структуру в **ЗАГОЛОВОЧНЫЙ ФАЙЛ.**

![](.gitbook/assets/56/22.png)

Теперь возникает вопрос

![](.gitbook/assets/56/23.png)

Я позволял себе редактировать внутри структуры **DRIVER**\_**OBJECT**, тип **MAJORFUNCTION** в **LOCAL TIPES** ?

![](.gitbook/assets/56/24.png)

Мы видим, что я изменил структуре определение поля **MAJORFUNCTION.** Внутри структуры **DRIVER**\_**OBJECT** для того, чтобы она была типа \_\_**MAJORFUNCTION**, который я определил.

![](.gitbook/assets/56/25.png)

![](.gitbook/assets/56/26.png)

Мы видим, что сейчас, если поля определены с их именами каждого указателя.

Когда мы нажимаем **T**, мы не можем выбрать структуру **DRIVER\_OBJECT**, потому что регистр **EDX** указывает на таблицу **MAJORFUNCTION**, поэтому я выбираю последнюю.

![](.gitbook/assets/56/27.png)

![](.gitbook/assets/56/28.png)

Сейчас стало намного лучше. Все в порядке. Я определил функции, которые будут использоваться, т. е. **\_MJ\_CREATE**, \_**MJ**\_**CLOSE**, **\_MJ\_DEVICE**\_**CONTROL** и те, которые будет вызываться, когда драйвер останавливается через функцию **DRIVERUNLOAD**.

Очевидно, когда из режима пользователя мы вызвали функцию **CREATEFILE**, вызывается функция, которая перезаписывает поле **\_MJ\_CREATE.** Когда мы передаем **IOCTL** код в функцию **DEVICEIOCONTROL**, вызывается **\_MJ\_DEVICE\_CONTROL.** Когда вызывается функция **CLOSEHANDLE**, драйвер вызывает ту, которая перезаписывает поле **\_MJ\_CLOSE.** И когда драйвер останавливается, вызывается та, которая перезаписывает функцию **DRIVERUNLOAD**.

Мы будем смотреть на функцию, которая будет вызываться при передаче **IOCTL**.

Мы синхронизируем структуру **IRP** из вкладки **LOCAL** **TYPES.**

Как мы видели в части **53**, поле **60** из **IRP** указывает на структуру \_**IO**\_**STACK**\_**LOCATION.**

![](.gitbook/assets/56/29.png)

Регистр **ESI** указывает на **\_IO\_STACK\_LOCATION**, поэтому все, что равно **ESI** + **XXX**, будет полем вышеупомянутой структуры. После синхронизации из вкладки **LOCAL** **TYPES**.

Напомним, что у структуры **\_IO\_STACK\_LOCATION** есть несколько опций. Я выберу ту, которая соответствует **IOCONTROLCODE**.

![](.gitbook/assets/56/30.png)

Мы видим, что в соответствии с кодом **IOCTL,** **SWITCH** отправляет нас в разные блоки и что они помечены типом уязвимости, который имеет каждый путь.

![](.gitbook/assets/56/31.png)

![](.gitbook/assets/56/32.png)

Здесь есть один блок, который говорит нам, что он имеет **STACKOVERFLOW**. Поэтому вам не нужно слишком сильно себя утруждать и искать переполнение.

![](.gitbook/assets/56/33.png)

Мы видим, что есть два аргумента, которые передают в регистре **EDI** структуру **IRP** а в регистре **ESI IRPSP** - это имя переменной типа \_**IO**\_**STACK**\_**LOCATION**, которая была в регистре **ESI**.

![](.gitbook/assets/56/34.png)

![](.gitbook/assets/56/35.png)

Это указатель на входной буфер. Также в этой же субструктуре находится **IOCONTROLCODE** и длина входного и выходного буфера. Предположительно эти значения передаются то же. Давайте посмотрим, что с ними делать.

![](.gitbook/assets/56/36.png)

Мы видим, что этот **SIZE** и этот буфер передаются в функцию \_**TRIGGERSTACKOVERFLOW**.

![](.gitbook/assets/56/37.png)

Мы видим, что драйвер помещает нуль с помощью регистра **ESI** в первый **DWORD** буфера **KERNELBUFFER** и затем с помощью функции **MEMSET** помещает нуль в следующий **DWORD**, так как происходит сложение **KERNELBUFFER + 4**, и получается размер **0x7FC**.

![](.gitbook/assets/56/38.png)

Вышеупомянутый буфер имеет длину **512** \* **4**, так как это массив **DWORD** \(**DD**\), поэтому общая длина в десятичной системе равна:

**512 \* 4
Out\[64\]: 2048**

В **HEX** это

**hex\(2048\)
Out\[65\]: '0x800'**

Поэтому, поместив в первый **DWORD** нуль, а затем в оставшиеся **0x7FC байт.** Действительно, драйвер заполнит весь буфер размером **0x800** нулями. \(**0x7FC** + **4** = **0x800\)**

Затем драйвер вызовет функцию **PROBEFORREAD**, которая проверит, выровнен ли входной буфер в пользовательском режиме и находится ли он в пользовательском пространстве.

![](.gitbook/assets/56/39.png)

![](.gitbook/assets/56/40.png)

Затем драйвер печатает указатели буферов и их размеры.

![](.gitbook/assets/56/41.png)

Здесь мы ясно видим переполнение стека, поскольку драйвер использует размер, который я передаю ему как данные для копирования из входного буфера в пользовательский, в буфер в ядре, который является назначением.

![](.gitbook/assets/56/42.png)

![](.gitbook/assets/56/43.png)

Здесь мы видим, что при печати размера буфера ядра, драйвер используйте тот, который находится в регистре **ESI**, который является константой **0x800**, но при выполнении функции **MEMCPY** он используйте аргумент **SIZE**, который я передал ему, без каких-либо проверок, которые будут приводить к переполнению стека и поскольку здесь нет **COOKIE**, он будет легко переполняться.

В следующей части мы будем делать скрипт с эксплуатацией. На этом здесь, мы закончим анализ.

**=======================================================
Автор текста: Рикардо Нарваха** - **Ricardo** **Narvaja** \(**@ricnar456**\)
Перевод на русский с испанского: **Яша\_Добрый\_Хакер\(Ростовский фанат Нарвахи\).**
Перевод специально для форума системного и низкоуровневого программирования — **WASM.IN
06.11.2018
Версия 1.0**
