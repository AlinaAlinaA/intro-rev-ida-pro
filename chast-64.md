# Часть 64

 Реверсинг задачи по SCADA  
  
В группе телеграмм мы поставили перед собой задачу, которая относится к реверсингу следующего **CVE**, чтобы практиковаться с реальным программным обеспечением.  
  
**CVE-2013-0657**  
  
[https://ics-cert.us-cert.gov/advisories/ICSA-13-018-01](https://ics-cert.us-cert.gov/advisories/ICSA-13-018-01)  
  
Здесь есть ссылка. Все версии и **9** и **10** являются уязвимыми, за исключением тех версий, к которым был применен патч.  
  
![1.png](https://wasm.in/attachments/1-png.4849/)  
  
Уязвимую версию **9** можно загрузить отсюда:  
  
[**HTTPS://DRIVE.GOOGLE.COM/OPEN?ID=1V4DAVXWD6FYSMVK4UKRG-SHCJNXI55XN**](https://drive.google.com/OPEN?ID=1V4DAVXWD6FYSMVK4UKRG-SHCJNXI55XN)  
  
А патч отсюда:  
  
[**HTTP://IGSS.SCHNEIDER-ELECTRIC.COM/IGSS/IGSSUPDATES/V90/PROGUPDATESV90.ZIP**](http://igss.schneider-electric.com/IGSS/IGSSUPDATES/V90/PROGUPDATESV90.ZIP)  
  
Это исполняемый файл, который прослушивает порт **TCP 12397**. Если мы установим программу, мы увидим, какой исполняемый файл прослушивает этот порт.  
  
Когда я устанавливаю программу, я сначала выбираю опцию **DEMO**, а затем **FREE FOR 50**. С этими настройками я могу запустить программу нормально. И когда я нажимаю на кнопку **START**, программа начинает работать. Если она не запускается, то можно удалить и создать новый проект с меньшим количеством элементов, так как программа даёт до **50** бесплатных элементов. Но здесь я её запускаю.  
  
![2.png](https://wasm.in/attachments/2-png.4850/)   
  
Мы видим, что процесс на моей машине имеет **PID** равный **3116**.  
  
![3.png](https://wasm.in/attachments/3-png.4851/)   
  
Для того, чтобы все хорошо работало нужно перейти на **DESIGN AND SETUP**, удалить старый проект и создать новый с **50** элементами или меньше и запустить программу. С этими настройками будет то, что нужно.  
  
![4.png](https://wasm.in/attachments/4-png.4852/)   
  
Мы уже примерно понимаем, что происходит. Давайте сделаем **DIFF** между двумя **DC.EXE**. Оригинальный в моем случае это версия:  
  
![5.png](https://wasm.in/attachments/5-png.4853/)   
  
И та версия, к которой применен патч:  
  
![6.png](https://wasm.in/attachments/6-png.4854/)   
  
При терпеливом осмотре видно, что в **DC.EXE** есть много измененных функций. Я не собираюсь анализировать их одну за другой, но здесь есть переполнение стека. Стрелка указывает на патч.  
  
![7.png](https://wasm.in/attachments/7-png.4855/)   
  
Я ищу среди импортируемых функций **RECV**. Мы видим, что она находится здесь, и видно, что она вызывается из одного места.  
  
![8.png](https://wasm.in/attachments/8-png.4856/)   
  
![9.png](https://wasm.in/attachments/9-png.4857/)   
  
Я ищу **32**-х битный удаленный сервер **IDA** и копирую его на машину, на которую я установил программу, и запускаю его как администратор.  
  
![10.png](https://wasm.in/attachments/10-png.4858/)   
  
В **IDA** я меняю отладчик на **REMOTE WINDOWS DEBUGGER**.  
  
![11.png](https://wasm.in/attachments/11-png.4859/)   
  
И настраиваю опции процесса \(**PROCESS OPTIONS**\) указывая **IP** адрес машины и её порт.  
  
![12.png](https://wasm.in/attachments/12-png.4860/)   
  
![13.png](https://wasm.in/attachments/13-png.4861/)   
  
Когда мы идем в **ATTACH PROCESS**, мы получаем список процессов на целевой машине если соединение между ними возможно \(нет брандмауэров или блокировок и т.д.\).  
  
![14.png](https://wasm.in/attachments/14-png.4862/)   
  
Здесь находится **DC.EXE**. Мы выбираем его и присоединяемся к нему.  
Чтобы проверить, что это действительно функция **RECV**, которую мы нашли, я поставил на эту функцию **BP**.  
  
![15.png](https://wasm.in/attachments/15-png.4863/)   
  
Я создаю скрипт **PYTHON**, который отправляет данные на порт **12397**, который прослушивает **DC.EXE**. Я отправляю в порт вручную **300** букв **A** просто для проверки, проверить произойдет ли остановка.  
  
![16.png](https://wasm.in/attachments/16-png.4864/)   
  
Мы видим, что отладчик останавливается.  
  
![17.png](https://wasm.in/attachments/17-png.4865/)   
  
Мы видим, что в первый раз, отладчик останавливается. Программа получает только восемь байтов, поэтому очевидно, что будет ещё остановка на функции.  
  
Если я нажимаю **RUN** без реверсинга много раз, я вижу, что пакет доходит до уязвимой функции.  
  
![18.png](https://wasm.in/attachments/18-png.4866/)   
  
Возможно только с этим программа не будет проходить по уязвимому пути. Программа постоянно останавливается на уязвимой функции. Это место нужно хорошо проанализировать.  
  
У нас нет символом. У нас нет ничего. Посмотрим куда мы сможем с этим добраться.  
  
![19.png](https://wasm.in/attachments/19-png.4867/)   
  
Мы видим, что есть указатель на структуру в этой переменной, которая называется **P\_STRUCT**.  
Каждый раз, когда значение читается, поле в структуре всегда доступно путем добавления смещения к этому адресу.  
  
Мы видим, что программа имеет большое смещение. Мы видим значения **0x64**, **0x3A4**, **0x37C**. Поэтому мы создадим структуру длиной **0x500** байт. Если нам понадобится размер больше, то мы увеличим ее. Если она меньше, то ничего страшного.  
  
Я создаю структуру с одним **DWORD** и расширяю её до **0x500**.  
  
![20.png](https://wasm.in/attachments/20-png.4868/)   
  
Это выглядит так. Поскольку уже было **4** байта плюс **0x500** в общей сложности мы получим **0x504** байт.  
  
![21.png](https://wasm.in/attachments/21-png.4869/)   
  
Я переименую структуру, чтобы получилось такое имя.  
  
![22.png](https://wasm.in/attachments/22-png.4870/)   
  
Мы видим, что **VAR\_4** это флаг, который может быть **0** или **1**. Есть место, где в это значение помещается значение **1**.  
  
![23.png](https://wasm.in/attachments/23-png.4871/)   
  
И в зависимости от **0** или **1** прежде чем вызвать **RECV** программа идет на правый блок или на левый.  
  
![24.png](https://wasm.in/attachments/24-png.4872/)   
  
Мы видим, что программа сравнивает значение с **0**. Если значение равно нулю, программа изменяет его на **1**, и в следующий раз программа проходит по пути **1**. Поэтому мы предполагаем, что начальное состояние флага равно **0**, и программа проходит через блок и устанавливается флаг в **1**.  
  
Таким образом, при первом пакете программа пройдет здесь. Перед **RECV**. Она поместит в регистр **ECX** значение **8**, что равно длине. Перед этим вычитается значение поля **0x3A4** из структуры, которое в начале равно **0**, так как мы уже увидели, что длина первого пакета должна быть **8**.  
  
![25.png](https://wasm.in/attachments/25-png.4873/)   
  
![26.png](https://wasm.in/attachments/26-png.4874/)   
  
Если я поищу константу **0x3A4**, я вижу, что здесь сохраняется сумма байтов, поэтому я переименую её.  
  
Я иду по структурам до смещения **0x3A4** той структуры которую я создал и нажимаю **D** до тех пор пока не появится **DWORD** и переименовываю поле.  
  
![27.png](https://wasm.in/attachments/27-png.4875/)   
  
Я могу искать смещение.  
  
![28.png](https://wasm.in/attachments/28-png.4876/)   
  
И затем с помощью **CTRL**+**I** я ищу все вхождения этого смещения и переименовываю в то же самое имя.  
  
![29.png](https://wasm.in/attachments/29-png.4877/)   
  
Я могу начать заново с начала функции.  
  
![30.png](https://wasm.in/attachments/30-png.4878/)   
  
Теперь выглядит лучше. По крайней мере, в той области функции, над которой я работаю.  
  
![31.png](https://wasm.in/attachments/31-png.4879/)   
  
Также мы видим, что во второй раз, когда программа пройдет через первый блок предыдущего изображения, уже прочитано **8** байт и программа пойдет по правому пути.  
  
Мы видим также, что в поле **0x64** есть указатель на вторую структуру, которая имеет буфер внутри со смещением **0x7008** и который отчитывается от **EDX**, который на данный момент равен нулю, поскольку это сумма прочитанных байтов. В начале она равна нулю.  
  
![32.png](https://wasm.in/attachments/32-png.4880/)   
  
Я создам следующую структуру как минимум **0x10000** байт. Не важно если будет больше.  
  
![33.png](https://wasm.in/attachments/33-png.4881/)   
  
По смещению **0x64** структуры **MI\_STRUCT** есть указатель на **STRUCT\_2**, поэтому я иду туда. Я нажимаю **D** до тех пор, пока не будет создан **DWORD**, а затем делаю смещение на структуру.  
  
![34.png](https://wasm.in/attachments/34-png.4882/)   
  
Я выбираю **STRUCT\_2** и оставляю всё так.  
  
![35.png](https://wasm.in/attachments/35-png.4883/)   
  
![36.png](https://wasm.in/attachments/36-png.4884/)   
  
По смещению **0x7008** начинается буфер, где программа будет хранить данные **RECV**. Поскольку это инструкция **LEA**, это не указатель на буфер, но он находится внутри той же самой структуры **STRUCT\_2**.  
  
В структурах я иду по адресу **0x7008** структуры **STRUCT\_2** и создаю буфер.  
  
Я предварительно создам **0x1000** байт.  
  
![37.png](https://wasm.in/attachments/37-png.4885/)   
  
![38.png](https://wasm.in/attachments/38-png.4886/)   
  
![39.png](https://wasm.in/attachments/39-png.4887/)   
  
Сейчас смотрится лучше.  
  
Если мы сделаем **SEARCH FOR INMEDIATE VALUE** со значением **0x7008** по всей программе.  
  
![40.png](https://wasm.in/attachments/40-png.4888/)   
  
Мы видим, что есть больше двух мест, где программа использует это смещение. Давайте посмотрим.  
  
![41.png](https://wasm.in/attachments/41-png.4889/)   
  
Первое вхождение находится в начале той же функции, которая читает, указатель на **STRUCT\_2** и добавляет **0x7008**, и это дает указатель на буфер, в котором программа сохраняет байты, поэтому я переименую переменную, в которой программа сохраняет, в **P\_BUFFER**.  
  
![42.png](https://wasm.in/attachments/42-png.4890/)   
  
Здесь мы видим, как программа ищет содержимое **P\_BUFFER**, т.е. первый **DWORD** его и это значение должно быть меньше **0x7000**. Мы можем проверить это, поставив **BP** на сравнении.  
  
![43.png](https://wasm.in/attachments/43-png.4891/)   
  
Я изменяю пакет, который я отправляю чтобы первые **4** байта были разными. В этом случае у меня получается значение **0x41424344**.  
  
Таким образом, из **8** байтов, которые программа читает, она проверяет, если первые **4** байта меньше чем **0x7000**.  
  
![44.png](https://wasm.in/attachments/44-png.4892/)   
  
Я поменяю значение в скрипте на **0x2000**.  
  
![45.png](https://wasm.in/attachments/45-png.4893/)   
  
![46.png](https://wasm.in/attachments/46-png.4894/)   
  
Сейчас то что нужно.  
  
Поэтому мы продолжаем здесь.  
  
![47.png](https://wasm.in/attachments/47-png.4895/)   
  
Содержимое P\_BUFFER это 0x2000.  
  
![48.png](https://wasm.in/attachments/48-png.4896/)   
  
В PRINTF это помогает нам увидеть, что есть три значения, которые будут напечатаны LENGHT, SOCKET и TCPRECVMSG, поэтому мы можем видеть, можем ли мы что-то переименовать с этими именами.  
  
![49.png](https://wasm.in/attachments/49-png.4897/)   
  
Давайте напомним, что в поле MI\_STRUCT 0X37C находится сокет. Мы переименуем поле.  
  
![50.png](https://wasm.in/attachments/50-png.4898/)   
  
![51.png](https://wasm.in/attachments/51-png.4899/)   
  
![52.png](https://wasm.in/attachments/52-png.4900/)   
  
И здесь где я реверсил.  
  
![53.png](https://wasm.in/attachments/53-png.4901/)   
  
В другое поле я поместил TCPRECVMSG как мне говорил PRINTF. Я ещё не знаю для чего оно используется, но я его идентифицирую.  
  
![54.png](https://wasm.in/attachments/54-png.4902/)   
  
Последнее что делается в этом блоке это читается размер и сохраняется в переменную.  
  
![55.png](https://wasm.in/attachments/55-png.4903/)   
  
И программа очищает сумму прочитанных байтов и повторяет цикл, возвращаясь назад с размером 0x2000.  
  
![56.png](https://wasm.in/attachments/56-png.4904/)   
  
В конце концов программа читает размер 0x2000 и не вычитает ничего поскольку сумма равна нулю, поэтому программа сохраняет 0x2000 в LEN и вызывает заново RECV.  
  
![57.png](https://wasm.in/attachments/57-png.4905/)   
  
Затем программа приходит к сравнению флага, который сейчас равен 1.  
  
![58.png](https://wasm.in/attachments/58-png.4906/)   
  
Если программа прочитает 0x2000 байт, которые я ей прислал, поскольку пакет сейчас находится здесь.  
  
![59.png](https://wasm.in/attachments/59-png.4907/)   
  
Для того, чтобы программа смогла прочитать спокойно 0x2000 байт во втором вызове RECV.  
  
Если программа прочитала нормально, она выходит из функции LEYENDO. В EAX помещается 0. Если всё в порядке.  
  
![60.png](https://wasm.in/attachments/60-png.4908/)   
  
![61.png](https://wasm.in/attachments/61-png.4909/)   
  
![62.png](https://wasm.in/attachments/62-png.4910/)   
  
Это другая функция, где читается буфер. Я переименую её в COPY. Я вижу, что программа вызывает её прямо под тем местом где я нахожусь.  
  
![63.png](https://wasm.in/attachments/63-png.4911/)   
  
![64.png](https://wasm.in/attachments/64-png.4912/)   
  
Я вижу, что DESTINATION функции MEMCPY внутри COPY это буфер который я переименую как \_DESTINATION. Туда скопируются мои данные.  
  
![65.png](https://wasm.in/attachments/65-png.4913/)   
  
Также мы видим, что здесь это P\_SIZE который передаётся в MEMCPY.  
  
![66.png](https://wasm.in/attachments/66-png.4914/)   
  
И что буфер \_DESTINATION состоит из 0x7004 байт, поэтому здесь не будет переполнения, потому что если при сравнении размер был меньше чем 0x7000, а если бы он был больше программа шла бы по другому пути где читается только 0x7000 как максимум.  
  
Также мы видим, что есть указатель на \_DESTINATION который сохраняется в другую переменную. Я переименовываю.  
  
![67.png](https://wasm.in/attachments/67-png.4915/)   
  
![68.png](https://wasm.in/attachments/68-png.4916/)   
  
Здесь программа сравнивает один из 0x2000 байт, которые я прислал ей со значением 0x9C, но похоже, что путь слева, связанный с разжатием данных, указанных в строке. Другой путь, похоже, не выбрасывает вас, поэтому я могу подумать, что если байт равен 0x9C, это флаг сжатия, а пока давайте не будем туда заходить и пойдет по правой стороне.  
  
![69.png](https://wasm.in/attachments/69-png.4917/)   
  
Здесь снова программа сравнивает размер с 0x7000. Нет проблемы со знаком, несмотря на то, что используется JLE, потому что это зависит от количества прочитанных байтов и не может прочитаться столько, для того чтобы там было отрицательное значение, так что там ничего нет.  
  
Мы видим что копируется мой буфер \_DESTINATION в другой, которая вызывает DST, который также по длине равен 0x7004.  
  
![70.png](https://wasm.in/attachments/70-png.4918/)   
  
Мы видим, что-то, что называет SRC, на самом деле является указателем на DST, который является местом куда я копирую свои фрукты.  
  
![71.png](https://wasm.in/attachments/71-png.4919/)   
  
Также здесь есть структура.  
  
![72.png](https://wasm.in/attachments/72-png.4920/)   
  
Её поле 0x2A8, по-видимому, является номером сеанса. Поэтому я создам третью структуру и в неё добавлю поле SESIÓN\_NUMBER.  
  
![73.png](https://wasm.in/attachments/73-png.4921/)   
  
Прежде чем мы продолжим, нужно объяснить одну вещь. Эта задача трудна не только потому, что у нас нет символов, но также и потому, что не существует верного пути между точкой RECV, куда приходит наша информация и уязвимой функцией.  
  
Если я помещу BP на уязвимую функцию, я увижу, что программа постоянно каждые несколько секунд останавливается на ней. По-видимому, как если бы это был поток, отличный от RECV, и нам нужно посмотреть, как вы можете добраться до него, несмотря на это, поэтому без символов и с этим трудом нам придется выжать все возможности статического реверсинга и, наконец динамическое тоже, чтобы помочь нам в том, что на войне и в реверсинге все годится. Мы увидим, как это сделать.  
  
Итак, мы добрались до SWITCH. Затем здесь есть несколько путей. Чтобы посмотреть, какой из них приведет нас к уязвимой функции, давайте немного разберем ее, чтобы попытаться выяснить, откуда взялась эта величина и можем ли мы на нее повлиять.  
  
![74.png](https://wasm.in/attachments/74-png.4922/)   
  
Мы видим, что есть буфер. Я пометил его как P\_DST. Его первый WORD - это значение, которое фильтруется. Мы видели это в патче, если это значение меньше 20, программа вас выбрасываете.  
  
![75.png](https://wasm.in/attachments/75-png.4923/)   
  
Таким образом, программа оценивает, если значение меньше 0x800, например 0x10, программа идет вправо, затем перечитывает значение и вычитает 0x20, сохраняя результат и используя этот отрицательный размер в качестве размера MEMCPY для стека, который переполняет его.  
  
Чтобы избежать этого, в патче проверяют перед вычитанием, чтобы значение было больше 0x20 перед переходом к процедуре.  
  
![76.png](https://wasm.in/attachments/76-png.4924/)   
  
Здесь в пропатченной функции, если она не ниже JNB программа переходит в зону вычитания с 0x20, чтобы она не была отрицательной.  
  
![77.png](https://wasm.in/attachments/77-png.4925/)   
  
 Проблема здесь заключается в том, что в первом вызове MEMCPY функция DESTINATION является P\_DEST, откуда она получает значение, возможно, наше, с размером 0x20, но здесь не ясно, кто является источником MEMCPY, кажется, что программа вычисляет его в той же функции, поэтому нам придется немного проанализировать её, чтобы увидеть, откуда исходит SRC и, конечно, наше значение, которое будет в первом WORD этого буфера, как SRC, так и DESTINATION, так как программа копирует в другие первые 0x20 байтов.  
  
Я уже реверсировал этот блок, так что вы увидите некоторые имена, которые уже установлены, но я объясню немного, что внутри в функции A\_MEMCPY есть еще одна, которая, наконец, переходит к функции MEMCPY.  
  
![1.png](https://wasm.in/attachments/1-png.4934/)   
  
Здесь это CALL который копирует данные.  
  
![2.png](https://wasm.in/attachments/2-png.4935/)   
  
Внутри этой функции.  
  
![3.png](https://wasm.in/attachments/3-png.4936/)   
  
Это было бы предполагаемое место для падения. Если мы передадим значение меньше 0x20, которое будет вычитаться из 0x20 и будет отрицательного размера.  
  
Переименуйте DST как P\_DST, так как это указатель, который указывает на буфер стека, который здесь не виден, но если вы проследуете по ссылкам, чтобы увидеть, откуда он взялся.  
  
Мы видим, что это аргумент этой функции. Если я посмотрю на ссылку.  
  
![4.png](https://wasm.in/attachments/4-png.4937/)   
  
![5.png](https://wasm.in/attachments/5-png.4938/)   
  
Также это аргумент типа указатель.  
  
![6.png](https://wasm.in/attachments/6-png.4939/)   
  
И в ссылке которая является уязвимой функцией также это аргумент типа указатель.  
  
![7.png](https://wasm.in/attachments/7-png.4940/)   
  
И в этой ссылке, это переменная типа указатель также которая называется SRC. Давайте посмотрим откуда она идет.  
  
![8.png](https://wasm.in/attachments/8-png.4941/)   
  
Мы видим, что это буфер в стеке откуда берется адрес и сохраняется в переменную указатель SRC.  
  
![9.png](https://wasm.in/attachments/9-png.4942/)   
  
Давайте посмотрим длину буфера.  
  
![10.png](https://wasm.in/attachments/10-png.4943/)   
  
Он равен 2052, т.е. 0x804  
  
Python&gt;HEX\(2052\)  
  
0x804  
  
Поэтому если мы сможем скопировать чуть больше 0x804 произойдет переполнение. Мы уже видели, что можно создать с помощью вычитания отрицательный размер, поэтому мы можем переписать весь стек, включая SEH, если у него есть COOKIE.  
  
Мы видим, что перед возвратом из этой функции, которая имеет буфер есть проверка COOKIE.  
  
![11.png](https://wasm.in/attachments/11-png.4944/)   
  
Мы также можем избежать этого перезаписав SEH, так что давайте продолжим.  
  
![12.png](https://wasm.in/attachments/12-png.4945/)   
  
В последнем вызове MEMCPY, чтобы увидеть, откуда берутся данные которые будут копироваться здесь, мы видим, что есть инструкция LEA, результатом которой является указатель на SRC, есть вызов EDX \* 2 внутри инструкции LEA, поэтому я предполагаю, что регистр EDX будет смещением, так как указатель не умножается, и если смещение, а регистр EAX будет базовым указателем буфера SRC, поэтому я поставил P\_SOURCE, возможно, регистр EDX равен 0 в начале и в конце копирует из начала буфера, указанного P\_SOURCE.  
  
Хорошо. P\_SOURCE это переменная типа указатель. Давайте вернемся назад, и посмотрим откуда она взялась.  
  
![13.png](https://wasm.in/attachments/13-png.4946/)   
  
Мы видим, что здесь программа сохраняет его и что оставляет поле 0xC структуры, и поскольку я понятия не имею что это, я назвал его как STRUCT\_SIZES. Вы увидите почему это так дальше. Но может подойти и любое имя.  
  
Так я создал маленькую структуру из 4 байт и назвал её так.  
  
![14.png](https://wasm.in/attachments/14-png.4947/)   
  
![15.png](https://wasm.in/attachments/15-png.4948/)   
  
Мы смотрим выше, потому что на данный момент это не имеет большого значения, что SIZE\_MEMCPY сравнивается с вычитанием первыми двумя DWORDS структуры, которые я назвал SIZE1 и SIZE2, и если SIZE\_MEMCPY меньше, чем вычитание обоих, программа будет использовать это, если не другой.  
  
![16.png](https://wasm.in/attachments/16-png.4949/)   
  
![17.png](https://wasm.in/attachments/17-png.4950/)   
  
Мы видим также, что P\_SOURCE структуры STRUCT\_SIZES используется раньше и что он не сохраняется в этой функции, поскольку при просмотре всех мест, которые использует P\_STRUCT\_SIZES, нет ни одного, который бы сохранял указатель в этом поле.  
  
![18.png](https://wasm.in/attachments/18-png.4951/)   
  
Всего лишь читаем здесь. Давайте посмотрим на ссылку.  
  
Мы видим, что указатель на структуру генерируется и сохраняется здесь, поэтому создание указателя P\_SOURCE должно быть позже этого.  
  
![19.png](https://wasm.in/attachments/19-png.4952/)   
  
Давайте проанализируем здесь формулу как рассчитывается указатель на структуру P\_STRUCT\_SIZES.  
  
Мы видим, что есть глобальная переменная, которую я назвал ее BASE\_DE\_SOURCE, содержимое которой является указателем, который является базой всего.  
  
![20.png](https://wasm.in/attachments/20-png.4953/)   
  
В регистр ECX помещается NUMERO\_ELEMENTOS. Возможно это смещение и затем идет добавление числа 4, другими словами из фиксированной глобальной переменной. Я могу найти её содержимое, добавив 4 b получить указатель на структуру в которой 4-тый DWORD будет иметь указатель на источник.  
  
Важно видеть, что SRC происходит из глобальной переменной, потому что, поскольку информация передается между потоками. Очень вероятно, что будет использоваться эта переменная для сохранения в потоке RECV и затем поднимать ее в другом потоке.  
  
Если мы запустим отладчик, мы увидим, что в глобальной переменной BASE\_DE\_SOURCE есть указатель. В моем случае он равен 0x1EBEBBB8.  
  
![21.png](https://wasm.in/attachments/21-png.4954/)   
  
Как мы помним, что к этому значению программа добавляет 4 и находит содержимое, которое является указателем на P\_STRUCT\_SIZES.  
  
![22.png](https://wasm.in/attachments/22-png.4955/)   
  
К содержимому BASE\_DE\_SOURCE я добавляю 4 и это содержимое - это P\_STRUCT\_SIZES. В моем случае это равно 0x2AB0038. Если я пойду туда и нажму T.  
  
![23.png](https://wasm.in/attachments/23-png.4956/)   
  
Поле 4 \(0xC\) является указателем на источник. Проще всего было бы перейти туда, где пусто, и поместить BPM, чтобы посмотреть, скопирую ли я туда свои фрукты и где это происходит.  
  
![24.png](https://wasm.in/attachments/24-png.4957/)   
  
![25.png](https://wasm.in/attachments/25-png.4958/)   
  
Мы видим, что отладчик остановился здесь.  
  
![26.png](https://wasm.in/attachments/26-png.4959/)   
  
И мы видим, что копируются мои фрукты.  
  
![27.png](https://wasm.in/attachments/27-png.4960/)   
  
Если мы посмотрим на CALL STACK.  
  
![28.png](https://wasm.in/attachments/28-png.4961/)   
  
Мы видим, что есть путь от LEYENDO, который проходит через SWITCH и который пишет там, и мы можем продолжить туда, где программа копирует данные.  
  
Мы видим, что второй раз копируется знаменитый 0x3E, который многие нашли в цикле, вместо нашего значения, поэтому мы знаем, куда идти и возможный путь. Теперь, когда нам ясно, мы должны продолжать смотреть на SWITCH.  
  
Также если мы посмотрим немного на способы получить эту копию из SWITCH.  
  
![29.png](https://wasm.in/attachments/29-png.4962/)   
  
Мы видим, что есть много способов попасть туда и мы прибываем не в то место, так как есть много действительных опкодов, которые приходят от COPIA, и мы бросаем что-нибудь, не обращаем внимания, что это действительный код операции.  
  
![30.png](https://wasm.in/attachments/30-png.4963/)   
  
![31.png](https://wasm.in/attachments/31-png.4964/)   
  
Я создам случайную строку и напечатаю ее, чтобы увидеть, какая позиция достигает OPCODE, чтобы исправить его.  
  
![32.png](https://wasm.in/attachments/32-png.4965/)   
  
![33.png](https://wasm.in/attachments/33-png.4966/)   
  
Мы исправляем пакет, который нам нужно передать.  
  
![34.png](https://wasm.in/attachments/34-png.4967/)   
  
Я поместил пакету размер 0x10, чтобы увидеть, что после установки правильных опкодов я дойду до уязвимой функции.  
  
![35.png](https://wasm.in/attachments/35-png.4968/)   
  
Я вижу, что отправляя программе 0x19 всегда и до тех пор, пока я выполняю RECV в конце после отправки, и соблюдаю длину пакета равную 0x6014, что является первыми двумя байтами размера, без проблем завершилась мной в MEMCPY.  
  
![36.png](https://wasm.in/attachments/36-png.4969/)   
  
Здесь программа падает. Я копирую весь стек.  
  
![37.png](https://wasm.in/attachments/37-png.4970/)   
  
Если кто-то не поместит recv, программа скопирует 0x3E в буфер, т.е. 0x3E это длина этого пакета, который создаётся, когда завершается соединение. Если мы увидим, что пакет имеет длину строки 0x3E.  
  
"SESSION TERMINATED"  
  
Если мы ищем эту строку, это будет здесь.  
  
![38.png](https://wasm.in/attachments/38-png.4971/)   
  
Указатель на эту вторую строку передается как второй аргумент.  
  
![39.png](https://wasm.in/attachments/39-png.4972/)   
  
Мы видим, что затем программа переходит к функции STRCPY, где она копирует строку в позицию 0x24 буфера, указатель которого находится в переменной VAR\_8.  
  
![40.png](https://wasm.in/attachments/40-png.4973/)   
  
Если VAR\_8 мы переименуем P\_DESTI то нужно посмотреть откуда он происходит.  
  
Мы видим, что это буфер в стеке, адрес которого хранится в переменной указателя P\_DESTI.  
  
![41.png](https://wasm.in/attachments/41-png.4974/)   
  
И в начале того же самого буфера должно сохраниться значение 0x3E. Оно происходит отсюда. Есть аргумент, который я назвал CONSTANTE.  
  
![42.png](https://wasm.in/attachments/42-png.4975/)   
  
На ссылке увидим, что это 1.  
  
![43.png](https://wasm.in/attachments/43-png.4976/)   
  
Мы видим, что программа сравнивает значение с 0x13.  
  
![44.png](https://wasm.in/attachments/44-png.4977/)   
  
Если оно меньше или равно, то всё хорошо, а если равно 1, то ничего не случиться.  
  
Мы видим, что к ECX прибавляется 1 y сохраняется значение 0x2 в EDX+0x22.  
  
![45.png](https://wasm.in/attachments/45-png.4978/)   
  
Есть также еще одна константа, которая выходит из длины строки SESSION TERMINATED.  
  
![46.png](https://wasm.in/attachments/46-png.4979/)   
  
К этой длине 0x12 программа добавляет 3 и выполняет SHR, 1  
  
shr eax, 1 ;Signed division by 2  
  
Т.е.  
  
![47.png](https://wasm.in/attachments/47-png.4980/)   
  
Что даёт нам значение 0xA.  
  
![48.png](https://wasm.in/attachments/48-png.4981/)   
  
Значит в позиции 0x22 есть 2, а в позиции 0x20 0xA.  
  
Программа складывает два значения здесь.  
  
![49.png](https://wasm.in/attachments/49-png.4982/)   
  
И затем к результату прибавляется сам результат и число 6.  
  
![50.png](https://wasm.in/attachments/50-png.4983/)   
  
Затем.  
  
![51.png](https://wasm.in/attachments/51-png.4984/)   
  
Программа добавляет значение 0x20, преобразуя его в значение 0x3E, которое переносит нас в конец сеанса, и сохраняет его в первом месте того буфера, который затем копирует.  
  
![52.png](https://wasm.in/attachments/52-png.4985/)   
  
Здесь внутри мы знаем, что программа скопировала его в наш буфер, из которого выходит значение, которое проходит через уязвимую функцию.  
  
А сейчас, почему если мы не поставим RECV, программа проходит здесь и все рушит? Вы можете сделать сравнение с и без RECV. Когда мы его убираем RECV программа проходит здесь. Если у программы есть RECV она не проходит и поскольку строка говорит, что сессия завершена, мы можем предположить, что recv поддерживает сессию открытой, и во время сбоя любой......?, Если кто захочет, может проверить это, если это так, используя WIRESHARK, просматривая, если соединение рвется, программа идет сюда, чтобы скопировать 0x3E, а если всё нормально, то она упадет.  
  
Чтобы вы не думали что я вру.  
  
![53.png](https://wasm.in/attachments/53-png.4986/)   
  
Я удаляю RECV и запускаю.  
  
![54.png](https://wasm.in/attachments/54-png.4987/)   
  
Мы видим, что программа сохраняет здесь 0x3E.  
  
![55.png](https://wasm.in/attachments/55-png.4988/)   
  
Мы видим, что я трассирую до функции MEMCPY.  
  
![56.png](https://wasm.in/attachments/56-png.4989/)  
  
Мы видим, что 0x3E со строкой SESIÓN TERMINATED.  
  
Мы видим, что на DESTINATION у которого есть наши фрукты, будут перезаписаны, а 0x10 будет перезаписан 0x3E.  
  
![57.png](https://wasm.in/attachments/57-png.4990/)  
  
![58.png](https://wasm.in/attachments/58-png.4991/)   
  
Если я помещу BPA и помещу BP на уязвимую функцию, программа прочитает это значение.  
  
![59.png](https://wasm.in/attachments/59-png.4992/)   
  
Я нажимаю на RUN.  
  
![60.png](https://wasm.in/attachments/60-png.4993/)   
  
И здесь все передается, т.е. Мы можем закончить наш пример.  
  
В качестве последнего вопроса меня спросили, есть ли какой-либо способ увидеть с помощью IDA, есть ли какой-либо путь к глобальной переменной, чтобы получить место, где программа копирует данные.  
  
Мы пойдем на функцию откуда было копирование.  
  
![61.png](https://wasm.in/attachments/61-png.4994/)   
  
Делая двойной клик на глобальной переменной.  
  
![62.png](https://wasm.in/attachments/62-png.4995/)   
  
Я нажимаю на клавишу минус.  
  
![63.png](https://wasm.in/attachments/63-png.4996/)   
  
Затем делаю клик в пустой части и выбираю ADD NODE BY NAME.  
  
![64.png](https://wasm.in/attachments/64-png.4997/)   
  
Я выбираю SWITCH.  
  
Мы видим, что она осталась там свободной.  
  
![65.png](https://wasm.in/attachments/65-png.4998/)   
  
Давайте посмотрим есть ли пути между ними. Их конечно будет много.  
  
Если мы сделаем клик на SWITCH и выберем FIND PATH как BASE DE SOURCE это не функция и она не появляется в списке назначений, но если сделаем наоборот и выберем FIND PATH в BASE DE SOURCE.  
  
![66.png](https://wasm.in/attachments/66-png.4999/)   
  
![67.png](https://wasm.in/attachments/67-png.5000/)   
  
Этот блок мы можем покрасить через SWITCH→ PATHS.  
  
![68.png](https://wasm.in/attachments/68-png.5001/)   
  
Сейчас смотрится лучше.  
  
![69.png](https://wasm.in/attachments/69-png.5002/)   
  
Мы хотим получить список.  
  
![70.png](https://wasm.in/attachments/70-png.5003/)   
  
![71.png](https://wasm.in/attachments/71-png.5004/)   
  
Здесь есть путь от SWITCH к любым опкодам, которые приведут вас к функции A\_COPIA\_3\_0, и приведут вас к доступу к глобальной переменной, которую мы должны увидеть.  
  
Ну вот и всё. Это был серьзный соперник для нас, но, поскольку это настоящее программное обеспечение, у него есть свои заморочки, но чтобы победить его, вам нужно больше практиковаться, чтобы иметь больше навыков в статическом реверсинге.  
  
**=======================================================  
Автор текста: Рикардо Нарваха** - **Ricardo** **Narvaja** \(**@ricnar456**\)  
Перевод на русский с испанского: **Яша\_Добрый\_Хакер\(Ростовский фанат Нарвахи\).**  
Перевод специально для форума системного и низкоуровневого программирования — **WASM.IN  
18.04.2019  
Версия 1.0**

