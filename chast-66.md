# Часть 66 - ч1

 ТУТОРИАЛ ДЛЯ РЕШЕНИЯ ЗАДАНИЯ **NICO** ИЗ **EKOPARTY** **2018** - ЧАСТЬ **2**.  
  
Давайте сделаем скрипт на **PYTHON** для решения конкурсной задачи **NICO**, которую мы реверсировали в предыдущей части. Cкрипт основан на реверсинге, который мы делали, а также на решении, которое прислал мой дружбан **LUCAS** **KOW**, особенно это видно в части про **ROP**, и мы объясним, как это сделать.  
  
![1.png](https://wasm.in/attachments/1-png.5006/)   
  
Если я запускаю скрипт **LUCAS**, я вижу что останавливается счетчик de la fuga de capitales\(сложно понять без запуска про что он говорит\) и что запускается калькулятор. Поэтому давайте посмотрим на это всё.  
  
Очевидно, что, во-первых, устанавливается соединение с сервером, который будет прослушивать порт **41414**, как мы уже видели. В качестве **IP-**адреса я введу **127.0.0.1**, так как запускаю его на той же машине. Если сервер находится на удаленной машине, придется ввести **IP** машины, на которой работает этот сервер.  
  
![2.png](https://wasm.in/attachments/2-png.5007/)   
  
Здесь импортируется сокет и устанавливается соединение с ним. Напомним, что первый пакет назывался **HANDSHAKE**. Вам нужно отправить слово **HELLO**, и если все в порядке, программа вернёт **HI**.  
  
![3.png](https://wasm.in/attachments/3-png.5008/)   
  
Давайте напомним, что это проверяется в функции, которую я переименовал в **CHECK\_HANDSHAKE** после первого **RECV**. Мы установим **BP** на возврате из функции **RECV**.  
  
Сейчас, чтобы это было более удобнее я изменяю отладчик на **WINDBG**, который будет использоваться как локальный отладчик внутри **IDA**.  
  
![4.png](https://wasm.in/attachments/4-png.5009/)   
  
![5.png](https://wasm.in/attachments/5-png.5010/)   
  
Конечно, нужно удалить в **PROCESS** **OPTIONS** любую **CONNECTION** **STRING** которая будет.  
  
![6.png](https://wasm.in/attachments/6-png.5011/)   
  
Я помещаю **BP** и нажимаю на **START**.  
  
Отладчик останавливается.  
  
![7.png](https://wasm.in/attachments/7-png.5012/)   
  
Кто хочет увидеть адрес в **WINDBG,** нужно выполнить эту команду**.**  
  
![8.png](https://wasm.in/attachments/8-png.5013/)   
  
**WINDBG** показывает адрес как **IMAGEBASE** + **RVA.  
  
RVA** это расстояние от **IMAGEBASE.**  
  
В моём случае **RVA** = **0x1C59.**  
  
В **IDA** нет возможности показывать адреса как базу плюс **RVA**, но есть возможность показать как смещение от функции, которой оно принадлежит.  
  
![9.png](https://wasm.in/attachments/9-png.5014/)   
  
Если мы поставим эту галочку произойдут изменения.  
  
![10.png](https://wasm.in/attachments/10-png.5015/)   
  
Таким образом, если мы назовем эту функцию как **MAIN**, название будет совпадать со всеми именами, так как все здесь будут в **MAIN** + **189**.  
  
![11.png](https://wasm.in/attachments/11-png.5016/)   
  
И это всё приведет нас на правильный адрес, конечно **RIP** будет продолжать показывать числовое значение.  
  
Хотя сбоку будет показываться уточнение, которое равно **MAIN**+**189.**  
  
![12.png](https://wasm.in/attachments/12-png.5017/)   
  
Я думаю, что таким образом будет легче следовать по пунктам, которые я Вам показываю, потому что, если мы поставим одинаковые имена, они будут совпадать.  
  
![13.png](https://wasm.in/attachments/13-png.5018/)   
  
Если я посмотрю сейчас, и увижу что отладчик остановился, я вижу, что есть в **BUF**, наведя указатель мыши на строку **HELLO**.  
  
Если я пойду сюда и нажму на клавишу **A** у меня появится строка **ASCII**.  
  
![14.png](https://wasm.in/attachments/14-png.5019/)   
  
В **CHECK\_HANDSHAKE+27**, убедитесь, что вы переименовали функцию в то же имя, и вы можете перейти туда.  
  
![15.png](https://wasm.in/attachments/15-png.5020/)   
  
Она находится в **STRNCMP**. Если всё хорошо, функция вернет нуль, если обе строки одинаковые.  
  
![16.png](https://wasm.in/attachments/16-png.5021/)   
  
Поскольку строки одинаковые, в **FLAG\_OK** помещается **1**.  
  
![17.png](https://wasm.in/attachments/17-png.5022/)   
  
И затем программа пойдет на **HANDSHAKE** отвечая **HI.** И с этим мы понимаем, что у нас все в-порядке.  
  
![18.png](https://wasm.in/attachments/18-png.5023/)   
  
В скрипте я печатаю в ответе **HI**.  
  
![19.png](https://wasm.in/attachments/19-png.5024/)   
  
Затем я останавливаю сервер и обращаю внимание, что программа переходит на выполнение этой функции. Я переименовал её в **RECV\_AND\_PARSE**.  
  
![20.png](https://wasm.in/attachments/20-png.5025/)   
  
Если вы переименуете её также сможете добавить смещение через начало функции.  
  
![21.png](https://wasm.in/attachments/21-png.5026/)   
  
В **RECV\_AND\_PARSE+46** мы вернемся на **RECV**, хотя мы знаем, что он был **16** байтов, из **4** **DWORDS.** Мы бы создали структуру и уже бы примерно знали сколько равна каждая.  
  
![22.png](https://wasm.in/attachments/22-png.5027/)   
  
![23.png](https://wasm.in/attachments/23-png.5028/)   
  
Здесь мы видим четыре значения. Первое - это длина **3-**го **RECV**, который будет вызываться позже. В этом случае он пропускает **0x200** байт, потому что, как мы видели, мы могли бы переполниться здесь, но передав больше данных, это приведет к сбою программы при перезаписи **COOKIE**.  
  
![24.png](https://wasm.in/attachments/24-png.5029/)   
  
Давайте вспомним, что буфер, в который вы записали **3**-е **RECV**, был **0x200** т.е. **512** байт, поэтому, если мы передадим больше, программа сломается, чуть ниже есть **COOKIE**, поэтому значение будет **0x200**.  
  
Следующим значением будет код операции, который мы будем выполнять. Мы увидели, что **0x22222222** позволит нам лучше читать не только адрес возврата, но и **COOKIE** безопасности, что очень важно, поэтому второй **DWORD** равен **0x22222222**.  
  
![25.png](https://wasm.in/attachments/25-png.5030/)   
  
Третьим **DWORD** был уровень \(меньше или равный **0x200**\). Напомним, что он должен быть настолько большим, насколько это возможно, потому что в **STRNCAT** он использует его в как **COUNT**копируемой величины, и поскольку **0x200** - максимум. Мы будем использовать это значение.  
  
![26.png](https://wasm.in/attachments/26-png.5031/)   
  
Последнее это отрицательное смещение. Мы помним, что оно не может быть каким-либо значением, потому что оно должно быть добавлено к **P\_BUFFER\_512\_TERCER\_RECV**, и результирующий адрес будет там, где программа пишет **OK** в **STRCPY**.  
  
![27.png](https://wasm.in/attachments/27-png.5032/)   
  
Расстояние до **CONST\_0** это **0x48** поэтому мы перейдем как к смещению **0x48**.  
  
![28.png](https://wasm.in/attachments/28-png.5033/)   
  
![29.png](https://wasm.in/attachments/29-png.5034/)   
  
Что равно **0x48.**  
  
После этого мы напишем **ОК** в **CONST\_0**, которая, как мы знали, является тем же аргументом функции **OP\_0x22222222**.  
  
Это позволит нам в первом повторе, когда программа пройдет через все обратные адреса, достичь функции **STRNCAT**, которая все сделает.  
  
![30.png](https://wasm.in/attachments/30-png.5035/)   
Здесь находится то, что мы будем засылать на данный момент.  
  
![31.png](https://wasm.in/attachments/31-png.5036/)   
  
Я поставлю **BP** на **STRCPY**.  
  
![32.png](https://wasm.in/attachments/32-png.5037/)   
  
Я запустил скрипт и отправил программе пакет, которую мы сделали.  
  
Как только скрипт достигнет уровня **0**, программа перейдет к **STRCPY** как мы видели, и остановится там. Затем программа выйдет из всех повторений, увеличивая уровень каждый раз, когда будет выход, пока не дойдет до первого повтора, равного уровню **0x200**. Здесь мы видим, что мы перезаписываем **CONST\_0** отцовскую функцию и переходим на **STRNCAT**.  
  
![33.png](https://wasm.in/attachments/33-png.5038/)   
  
Программа скопирует **0x200** из **SOURCE**, что представляет собой буквы **A**, которые я отправил на 3-й **RECV**, и добавил его после **OK**, который является **DESTINATION**.  
  
![34.png](https://wasm.in/attachments/34-png.5039/)   
  
**SOURCE**  
  
![35.png](https://wasm.in/attachments/35-png.5040/)  
  
**DESTINATION**  
  
![36.png](https://wasm.in/attachments/36-png.5041/)  
  
Хорошо. С этим мы уже знаем, что мы перезапишем размер **SEND**. Давайте продолжим трассировать до нужного места.  
  
![37.png](https://wasm.in/attachments/37-png.5042/)   
  
Я вижу, что размер того, что программа собирается отправить переписан моими символами **A**. Проблема в том, что программа будет зависать, так как она не может читать так много и будет ломаться при чтении. Проблема в том, что нужно увидеть, какое значение передать, чтобы прочитать **COOKIE**, обратный адрес и ничего не поломать.  
  
Я останавливаю программу.  
  
Напомним, что мне начинает отправляться с начала **BUFFER\_512\_TERCER\_RECV** сумма, которую я хочу.  
  
![38.png](https://wasm.in/attachments/38-png.5043/)   
  
Возможное количество будет **544** байта от начала буфера, так как программа отправит мне **COOKIE** и адрес возврата. Так же, может быть передано более большее значение, но главное чтобы не сломает стек. То, что передает **LUCAS**, это значение **0x2FF.** Так как мы собираемся использовать его **ROP** давайте оценим это значение.  
  
![39.png](https://wasm.in/attachments/39-png.5044/)   
  
Как мы можем узнать какая из всех этих букв **A** это та которая перезаписывает размер?  
  
Это нужная функция  
  
import random, string  
  
def randomword\(length\):  
letters = string.ascii\_lowercase  
return ''.join\(random.choice\(letters\) for i in range\(length\)\)  
  
Я её добавляю.  
  
![40.png](https://wasm.in/attachments/40-png.5045/)   
  
Чтобы прочитать размер **SEND** программа говорит какие символы попадают прямо здесь.  
  
![41.png](https://wasm.in/attachments/41-png.5046/)   
  
В моём случае это **LOJW.** Я ищу их в строке который распечатал скрипт.  
  
![42.png](https://wasm.in/attachments/42-png.5047/)   
  
Я копирую строку и обращаю внимание на её длину.  
  
len\(**"nvcrphoxkyxmbvxefyyfxuhexaldxq"**\)  
  
Она равна **30**.  
  
![43.png](https://wasm.in/attachments/43-png.5048/)   
  
Поэтому я помещу **30** букв **A**, затем размер, который я хочу отправить. Я буду использовать тот же, который использовал **LUCAS** **0x2FF**, а затем дополню **0x200** байтов пакета большим количеством букв **A**.  
  
Давайте ещё раз запустим скрипт.  
  
![44.png](https://wasm.in/attachments/44-png.5049/)   
  
Мы видим, что размер подходит. Давайте дальше посмотрим, что мне вернется через **SEND**.  
  
Мы видим, что после букв **A** добавляются символы.  
  
![45.png](https://wasm.in/attachments/45-png.5050/)   
  
Напомним, что буфер был из **0x200** байт \(**512** десятичных\) поэтому сразу после этого идет **COOKIE**.  
  
**print "%r"**%data\[512:512+8\]  
  
Этим мы распечатаем значение **COOKIE.**  
  
Я запускаю скрипт снова, и когда он останавливается на **SEND**, я обращаю внимание на значение **COOKIE**.  
  
![46.png](https://wasm.in/attachments/46-png.5051/)   
  
При этом запуске в этом снимке в моем случае это то, что мы увидим если я нажму **RUN**. Если я распечатаю в скрипте те же **COOKIE**.  
  
![47.png](https://wasm.in/attachments/47-png.5052/)   
  
Это и есть те самые **COOKIE**.  
  
Если я добавлю к коду **import** binascii  
  
И использую это  
data = s.recv\(1024\)  
cookie=data\[512:512+8\]  
**print "%r"**%cookie  
**print** binascii.hexlify\(cookie\)  
  
И запускаю скрипт заново.  
  
**COOKIE** покажутся в новом виде.  
  
![48.png](https://wasm.in/attachments/48-png.5053/)   
  
![49.png](https://wasm.in/attachments/49-png.5054/)   
  
Я вижу, что совпадают значение. Если хочу распечатать с помощью **\X**.  
  
Это никак не влияет, это необязательно, но я делю строку на два символа, а затем с помощью **JOIN** добавляю **\X** посередине и впереди.  
  
![50.png](https://wasm.in/attachments/50-png.5055/)   
  
И заново запускаю скрипт, посмотреть что получилось.  
  
![51.png](https://wasm.in/attachments/51-png.5056/)   
  
![52.png](https://wasm.in/attachments/52-png.5057/)   
  
Уже лучше видно и у нас есть **COOKIE**.  
  
Следующее значение которое нужно получить это адрес возврата**.**  
  
![53.png](https://wasm.in/attachments/53-png.5058/)   
  
Он находится между **536** и **536**+**8**.  
Для того, чтобы это всё выглядело красиво я определил функцию **MY\_PRINT,** чтобы распечатать на свой вкус наши значения.  
  
![54.png](https://wasm.in/attachments/54-png.5059/)   
  
Когда программа достигает адреса возврата, я обращаю внимания куда она вернется. **ESP** будет указывать туда.  
  
![55.png](https://wasm.in/attachments/55-png.5060/)   
  
![56.png](https://wasm.in/attachments/56-png.5061/)   
  
У нас уже есть два наиболее важных значения: **COOKIE** и место куда бы я хотел вернуться.  
  
Очевидно, что при выходе из функции **RECV\_AND\_PARSE** программа бы вернулась туда, поэтому мы объединили этот адрес исполняемого файла.  
  
![57.png](https://wasm.in/attachments/57-png.5062/)   
  
Если я трассирую с помощью **F7** отсюда.  
  
![58.png](https://wasm.in/attachments/58-png.5063/)



## Нехватает огромного куска, часть 2, Яша забиыл

